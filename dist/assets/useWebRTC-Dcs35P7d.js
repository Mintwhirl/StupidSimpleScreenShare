import{r as n,j as z}from"./main-BQb3GjsF.js";const K=n.forwardRef(({className:l,...a},s)=>{const v=n.useRef(null),S=s||v;return n.useImperativeHandle(s,()=>v.current,[]),n.useEffect(()=>{const r=S.current;if(!r)return;const b=()=>{console.log("Video metadata loaded:",{duration:r.duration,videoWidth:r.videoWidth,videoHeight:r.videoHeight})},C=()=>{console.log("Video data loaded")},g=()=>{console.log("Video can start playing")},I=()=>{console.log("Video started playing")},k=()=>{console.log("Video paused")},u=()=>{console.log("Video ended")},$=F=>{console.error("Video error:",F)},V=()=>{console.log("Video waiting for data")},L=()=>{console.log("Video stalled")};return r.addEventListener("loadedmetadata",b),r.addEventListener("loadeddata",C),r.addEventListener("canplay",g),r.addEventListener("play",I),r.addEventListener("pause",k),r.addEventListener("ended",u),r.addEventListener("error",$),r.addEventListener("waiting",V),r.addEventListener("stalled",L),()=>{r.removeEventListener("loadedmetadata",b),r.removeEventListener("loadeddata",C),r.removeEventListener("canplay",g),r.removeEventListener("play",I),r.removeEventListener("pause",k),r.removeEventListener("ended",u),r.removeEventListener("error",$),r.removeEventListener("waiting",V),r.removeEventListener("stalled",L)}},[S]),z.jsx("video",{ref:S,className:l,"aria-label":"Screen sharing video stream",...a})});K.displayName="VideoPlayer";var _={};const Q=[{urls:"stun:stun.l.google.com:19302"},{urls:"stun:stun1.l.google.com:19302"},{urls:"stun:stun2.l.google.com:19302"},{urls:"stun:stun3.l.google.com:19302"},{urls:"stun:stun4.l.google.com:19302"}],G=[{urls:"turn:openrelay.metered.ca:80",username:"openrelayproject",credential:"openrelayproject"},{urls:"turn:openrelay.metered.ca:443",username:"openrelayproject",credential:"openrelayproject"},{urls:"turn:openrelay.metered.ca:443?transport=tcp",username:"openrelayproject",credential:"openrelayproject"},..._.TURN_SERVERS?JSON.parse(_.TURN_SERVERS):[]];function X(l=!1){const a=[...Q];return l&&G.length>0&&a.push(...G),a}const P=window.location.hostname==="localhost"||window.location.hostname.includes("localhost"),R={ERROR:0,WARN:1,INFO:2,DEBUG:3},N=P?R.DEBUG:R.ERROR;class Y{error(a,...s){N>=R.ERROR&&console.error(`[ERROR] ${a}`,...s)}warn(a,...s){N>=R.WARN&&console.warn(`[WARN] ${a}`,...s)}info(a,...s){N>=R.INFO&&console.info(`[INFO] ${a}`,...s)}debug(a,...s){N>=R.DEBUG&&console.debug(`[DEBUG] ${a}`,...s)}webrtc(a,s={}){P&&console.debug(`[WebRTC] ${a}`,s)}api(a,s,v={}){P&&console.debug(`[API] ${a} ${s}`,v)}user(a,s={}){P&&console.debug(`[USER] ${a}`,s)}}const d=new Y;function ee(l,a,s,v=null){const[S,r]=n.useState("disconnected"),[b,C]=n.useState(null),[g,I]=n.useState(null),[k,u]=n.useState(null),[$,V]=n.useState({}),[L,F]=n.useState([]),E=n.useRef(null),B=n.useRef(null),c=n.useRef(null),o=n.useRef(null),p=n.useRef(null),m=n.useRef(!0);n.useEffect(()=>{const e=X(s?.useTurn!==!1);F(e)},[s]);const x=n.useCallback(async e=>{if(!(!l||!a))try{const t=await fetch("/api/candidate",{method:"POST",headers:{"Content-Type":"application/json",...s?.authSecret&&{"x-auth-secret":s.authSecret}},body:JSON.stringify({roomId:l,role:a,viewerId:v,candidate:{candidate:e.candidate,sdpMid:e.sdpMid,sdpMLineIndex:e.sdpMLineIndex}})});if(!t.ok)throw new Error(`Failed to send ICE candidate: ${t.status}`)}catch(t){d.error("Error sending ICE candidate:",t),u(`Failed to send ICE candidate: ${t.message}`)}},[l,a,s,v]),T=n.useCallback(()=>{const e=new RTCPeerConnection({iceServers:L});return e.onicecandidate=t=>{t.candidate&&x(t.candidate)},e.onconnectionstatechange=()=>{d.webrtc("Connection state changed",{state:e.connectionState}),r(e.connectionState),(e.connectionState==="connected"||e.connectionState==="failed")&&(c.current&&(clearInterval(c.current),c.current=null),o.current&&(clearInterval(o.current),o.current=null),p.current&&(clearInterval(p.current),p.current=null))},e.oniceconnectionstatechange=()=>{d.webrtc("ICE connection state changed",{state:e.iceConnectionState})},e.ontrack=t=>{d.webrtc("Received remote stream",{stream:t.streams[0]}),C(t.streams[0])},e.ondatachannel=t=>{const f=t.channel;B.current=f,f.onopen=()=>{d.webrtc("Data channel opened")},f.onmessage=h=>{d.webrtc("Received data channel message",{data:h.data})}},e},[L,x]),D=n.useCallback(async e=>{if(l)try{const t=await fetch("/api/offer",{method:"POST",headers:{"Content-Type":"application/json",...s?.authSecret&&{"x-auth-secret":s.authSecret}},body:JSON.stringify({roomId:l,desc:e})});if(!t.ok)throw new Error(`Failed to send offer: ${t.status}`)}catch(t){d.error("Error sending offer:",t),u(`Failed to send offer: ${t.message}`)}},[l,s]),U=n.useCallback(async e=>{if(l)try{const t=await fetch("/api/answer",{method:"POST",headers:{"Content-Type":"application/json",...s?.authSecret&&{"x-auth-secret":s.authSecret}},body:JSON.stringify({roomId:l,desc:e})});if(!t.ok)throw new Error(`Failed to send answer: ${t.status}`)}catch(t){d.error("Error sending answer:",t),u(`Failed to send answer: ${t.message}`)}},[l,s]),A=n.useCallback(async()=>{c.current&&clearInterval(c.current);let e=0,t=1e3;const f=60,h=async()=>{try{if(e++,e>f){clearInterval(c.current),c.current=null,m.current&&(u("Connection timeout: No offer received from host. Make sure the host has started sharing."),r("failed"));return}const i=await fetch(`/api/offer?roomId=${l}`);if(i.ok){const y=await i.json();if(y.desc){clearInterval(c.current),c.current=null;const w=T();E.current=w,await w.setRemoteDescription(y.desc);const W=await w.createAnswer();await w.setLocalDescription(W),await U(W),O()}}else i.status===404?e>10&&(clearInterval(c.current),t=5e3,c.current=setInterval(h,t)):(d.error("Unexpected error polling for offers:",i.status),clearInterval(c.current),c.current=null,m.current&&(u(`Server error: ${i.status}`),r("failed")))}catch(i){d.error("Error polling for offers:",i),clearInterval(c.current),c.current=null,m.current&&(u(`Network error: ${i.message}`),r("failed"))}};c.current=setInterval(h,t)},[l,U,T,O]),M=n.useCallback(async()=>{o.current&&clearInterval(o.current);let e=0,t=1e3;const f=60,h=async()=>{try{if(e++,e>f){clearInterval(o.current),o.current=null,m.current&&(u("Connection timeout: No answer received from viewer. Make sure the viewer has connected."),r("failed"));return}const i=await fetch(`/api/answer?roomId=${l}`);if(i.ok){const y=await i.json();if(y.desc){clearInterval(o.current),o.current=null;const w=E.current;w&&await w.setRemoteDescription(y.desc)}}else i.status===404?e>10&&(clearInterval(o.current),t=5e3,o.current=setInterval(h,t)):(d.error("Unexpected error polling for answers:",i.status),clearInterval(o.current),o.current=null,m.current&&(u(`Server error: ${i.status}`),r("failed")))}catch(i){d.error("Error polling for answers:",i),clearInterval(o.current),o.current=null,m.current&&(u(`Network error: ${i.message}`),r("failed"))}};o.current=setInterval(h,t)},[l]),O=n.useCallback(async()=>{p.current&&clearInterval(p.current);let e=0;const t=120;p.current=setInterval(async()=>{try{if(e++,e>t){clearInterval(p.current),p.current=null,d.warn("ICE candidate polling timeout - connection may be stuck");return}const f=await fetch(`/api/candidate?roomId=${l}&role=${a}${v?`&viewerId=${v}`:""}`);if(f.ok){const h=await f.json();if(h.candidates&&h.candidates.length>0){const i=E.current;if(i)for(const y of h.candidates)try{await i.addIceCandidate(y)}catch(w){d.warn("Failed to add ICE candidate:",w)}}}else f.status!==404&&d.error("Error polling for ICE candidates:",f.status)}catch(f){d.error("Error polling for ICE candidates:",f)}},1e3)},[l,a,v]),H=n.useCallback(async()=>{if(a!=="host")throw new Error("Only hosts can start screen sharing");try{u(null),r("connecting");const e=await navigator.mediaDevices.getDisplayMedia({video:!0,audio:!0});I(e);const t=T();E.current=t,e.getTracks().forEach(h=>{t.addTrack(h,e)});const f=await t.createOffer({offerToReceiveAudio:!0,offerToReceiveVideo:!0});return await t.setLocalDescription(f),await D(f),M(),O(),e}catch(e){throw d.error("Error starting screen share:",e),u(`Failed to start screen sharing: ${e.message}`),r("disconnected"),e}},[a,T,D,M,O]),J=n.useCallback(async()=>{if(a!=="viewer")throw new Error("Only viewers can connect to host");try{u(null),r("connecting"),A()}catch(e){throw d.error("Error connecting to host:",e),u(`Failed to connect to host: ${e.message}`),r("disconnected"),e}},[a,A]),j=n.useCallback(async()=>{try{g&&(g.getTracks().forEach(e=>e.stop()),I(null)),E.current&&(E.current.close(),E.current=null),c.current&&(clearInterval(c.current),c.current=null),o.current&&(clearInterval(o.current),o.current=null),p.current&&(clearInterval(p.current),p.current=null),r("disconnected"),C(null)}catch(e){d.error("Error stopping screen share:",e),u(`Failed to stop screen sharing: ${e.message}`)}},[g]),q=n.useCallback(async()=>{await j()},[j]);return n.useEffect(()=>()=>{m.current=!1,c.current&&clearInterval(c.current),o.current&&clearInterval(o.current),p.current&&clearInterval(p.current),E.current&&E.current.close(),g&&g.getTracks().forEach(e=>e.stop())},[g]),{connectionState:S,remoteStream:b,localStream:g,error:k,peerConnections:$,startScreenShare:H,stopScreenShare:j,connectToHost:J,disconnect:q}}export{K as V,ee as u};
//# sourceMappingURL=useWebRTC-Dcs35P7d.js.map
