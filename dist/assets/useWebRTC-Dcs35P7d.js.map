{"version":3,"file":"useWebRTC-Dcs35P7d.js","sources":["../../src/components/VideoPlayer.jsx","../../src/config/turn.js","../../src/utils/logger.js","../../src/hooks/useWebRTC.js"],"sourcesContent":["import { forwardRef, useEffect, useRef, useImperativeHandle } from 'react';\n\nconst VideoPlayer = forwardRef(({ className, ...props }, ref) => {\n  const videoRef = useRef(null);\n  const internalRef = ref || videoRef;\n\n  // Use useImperativeHandle to properly handle ref forwarding\n  useImperativeHandle(ref, () => videoRef.current, []);\n\n  // Handle video element events\n  useEffect(() => {\n    const video = internalRef.current;\n    if (!video) return;\n\n    const handleLoadedMetadata = () => {\n      console.log('Video metadata loaded:', {\n        duration: video.duration,\n        videoWidth: video.videoWidth,\n        videoHeight: video.videoHeight,\n      });\n    };\n\n    const handleLoadedData = () => {\n      console.log('Video data loaded');\n    };\n\n    const handleCanPlay = () => {\n      console.log('Video can start playing');\n    };\n\n    const handlePlay = () => {\n      console.log('Video started playing');\n    };\n\n    const handlePause = () => {\n      console.log('Video paused');\n    };\n\n    const handleEnded = () => {\n      console.log('Video ended');\n    };\n\n    const handleError = (e) => {\n      console.error('Video error:', e);\n    };\n\n    const handleWaiting = () => {\n      console.log('Video waiting for data');\n    };\n\n    const handleStalled = () => {\n      console.log('Video stalled');\n    };\n\n    // Add event listeners\n    video.addEventListener('loadedmetadata', handleLoadedMetadata);\n    video.addEventListener('loadeddata', handleLoadedData);\n    video.addEventListener('canplay', handleCanPlay);\n    video.addEventListener('play', handlePlay);\n    video.addEventListener('pause', handlePause);\n    video.addEventListener('ended', handleEnded);\n    video.addEventListener('error', handleError);\n    video.addEventListener('waiting', handleWaiting);\n    video.addEventListener('stalled', handleStalled);\n\n    // Cleanup\n    return () => {\n      video.removeEventListener('loadedmetadata', handleLoadedMetadata);\n      video.removeEventListener('loadeddata', handleLoadedData);\n      video.removeEventListener('canplay', handleCanPlay);\n      video.removeEventListener('play', handlePlay);\n      video.removeEventListener('pause', handlePause);\n      video.removeEventListener('ended', handleEnded);\n      video.removeEventListener('error', handleError);\n      video.removeEventListener('waiting', handleWaiting);\n      video.removeEventListener('stalled', handleStalled);\n    };\n  }, [internalRef]);\n\n  return <video ref={internalRef} className={className} aria-label='Screen sharing video stream' {...props} />;\n});\n\nVideoPlayer.displayName = 'VideoPlayer';\n\nexport default VideoPlayer;\n","/**\n * TURN Server Configuration\n * Provides STUN and TURN servers for WebRTC connections\n */\n\n// Default STUN servers (free, no authentication required)\nconst DEFAULT_STUN_SERVERS = [\n  { urls: 'stun:stun.l.google.com:19302' },\n  { urls: 'stun:stun1.l.google.com:19302' },\n  { urls: 'stun:stun2.l.google.com:19302' },\n  { urls: 'stun:stun3.l.google.com:19302' },\n  { urls: 'stun:stun4.l.google.com:19302' },\n];\n\n// TURN servers (require authentication and may have costs)\nconst TURN_SERVERS = [\n  // Free TURN server for testing (may have limitations)\n  {\n    urls: 'turn:openrelay.metered.ca:80',\n    username: 'openrelayproject',\n    credential: 'openrelayproject',\n  },\n  {\n    urls: 'turn:openrelay.metered.ca:443',\n    username: 'openrelayproject',\n    credential: 'openrelayproject',\n  },\n  {\n    urls: 'turn:openrelay.metered.ca:443?transport=tcp',\n    username: 'openrelayproject',\n    credential: 'openrelayproject',\n  },\n  // Production TURN servers (if configured)\n  ...(process.env.TURN_SERVERS ? JSON.parse(process.env.TURN_SERVERS) : []),\n];\n\n/**\n * Get ICE servers configuration for WebRTC\n * @param {boolean} includeTurn - Whether to include TURN servers\n * @returns {Array} Array of ICE server configurations\n */\nexport function getIceServers(includeTurn = false) {\n  const iceServers = [...DEFAULT_STUN_SERVERS];\n\n  if (includeTurn && TURN_SERVERS.length > 0) {\n    iceServers.push(...TURN_SERVERS);\n  }\n\n  return iceServers;\n}\n\n/**\n * Get STUN servers only (for basic connectivity)\n * @returns {Array} Array of STUN server configurations\n */\nexport function getStunServers() {\n  return DEFAULT_STUN_SERVERS;\n}\n\n/**\n * Check if TURN servers are configured\n * @returns {boolean} True if TURN servers are available\n */\nexport function hasTurnServers() {\n  return TURN_SERVERS.length > 0 && process.env.TURN_USERNAME && process.env.TURN_PASSWORD;\n}\n\n/**\n * Get connection quality based on ICE gathering state\n * @param {RTCPeerConnection} peerConnection - The peer connection to check\n * @returns {string} Connection quality ('excellent', 'good', 'poor', 'unknown')\n */\nexport function getConnectionQuality(peerConnection) {\n  if (!peerConnection) return 'unknown';\n\n  // This is a simplified implementation\n  // In a real app, you'd analyze the stats for connection quality\n\n  switch (peerConnection.connectionState) {\n    case 'connected':\n      return 'excellent';\n    case 'connecting':\n      return 'good';\n    case 'disconnected':\n    case 'failed':\n      return 'poor';\n    default:\n      return 'unknown';\n  }\n}\n\n/**\n * Configure WebRTC with optimal settings\n * @param {RTCPeerConnection} peerConnection - The peer connection to configure\n * @param {boolean} useTurn - Whether to use TURN servers\n */\nexport function configureWebRTC(peerConnection, useTurn = false) {\n  if (!peerConnection) return;\n\n  // Set ICE servers\n  peerConnection.setConfiguration({\n    iceServers: getIceServers(useTurn),\n    iceCandidatePoolSize: 10,\n    iceTransportPolicy: useTurn ? 'all' : 'all',\n    bundlePolicy: 'max-bundle',\n    rtcpMuxPolicy: 'require',\n  });\n\n  // Configure ICE gathering\n  peerConnection.addEventListener('icegatheringstatechange', () => {\n    console.log('ICE gathering state:', peerConnection.iceGatheringState);\n  });\n\n  peerConnection.addEventListener('iceconnectionstatechange', () => {\n    console.log('ICE connection state:', peerConnection.iceConnectionState);\n  });\n}\n\nexport default {\n  getIceServers,\n  getStunServers,\n  hasTurnServers,\n  getConnectionQuality,\n  configureWebRTC,\n};\n","/**\r\n * Logger Utility\r\n * Centralized logging with environment-aware levels\r\n */\r\n\r\nconst isDevelopment = import.meta.env.DEV || \r\n  import.meta.env.MODE === 'development' || \r\n  import.meta.env.MODE === 'test' ||\r\n  window.location.hostname === 'localhost' ||\r\n  window.location.hostname.includes('localhost');\r\n\r\nconst isProduction = import.meta.env.PROD || \r\n  import.meta.env.MODE === 'production';\r\n\r\n/**\r\n * Log levels\r\n */\r\nconst LOG_LEVELS = {\r\n  ERROR: 0,\r\n  WARN: 1,\r\n  INFO: 2,\r\n  DEBUG: 3,\r\n};\r\n\r\n/**\r\n * Current log level based on environment\r\n */\r\nconst currentLogLevel = isDevelopment ? LOG_LEVELS.DEBUG : LOG_LEVELS.ERROR;\r\n\r\n/**\r\n * Logger class\r\n */\r\nclass Logger {\r\n  error(message, ...args) {\r\n    if (currentLogLevel >= LOG_LEVELS.ERROR) {\r\n      console.error(`[ERROR] ${message}`, ...args);\r\n    }\r\n  }\r\n\r\n  warn(message, ...args) {\r\n    if (currentLogLevel >= LOG_LEVELS.WARN) {\r\n      console.warn(`[WARN] ${message}`, ...args);\r\n    }\r\n  }\r\n\r\n  info(message, ...args) {\r\n    if (currentLogLevel >= LOG_LEVELS.INFO) {\r\n      console.info(`[INFO] ${message}`, ...args);\r\n    }\r\n  }\r\n\r\n  debug(message, ...args) {\r\n    if (currentLogLevel >= LOG_LEVELS.DEBUG) {\r\n      console.debug(`[DEBUG] ${message}`, ...args);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Log WebRTC events (only in development)\r\n   */\r\n  webrtc(event, data = {}) {\r\n    if (isDevelopment) {\r\n      console.debug(`[WebRTC] ${event}`, data);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Log API calls (only in development)\r\n   */\r\n  api(method, endpoint, data = {}) {\r\n    if (isDevelopment) {\r\n      console.debug(`[API] ${method} ${endpoint}`, data);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Log user actions (only in development)\r\n   */\r\n  user(action, data = {}) {\r\n    if (isDevelopment) {\r\n      console.debug(`[USER] ${action}`, data);\r\n    }\r\n  }\r\n}\r\n\r\n// Create singleton instance\r\nconst logger = new Logger();\r\n\r\nexport default logger;\r\n","import { useState, useEffect, useRef, useCallback } from 'react';\nimport { getIceServers } from '../config/turn.js';\nimport logger from '../utils/logger';\n\nexport function useWebRTC(roomId, role, config, _viewerId = null) {\n  // State\n  const [connectionState, setConnectionState] = useState('disconnected');\n  const [remoteStream, setRemoteStream] = useState(null);\n  const [localStream, setLocalStream] = useState(null);\n  const [error, setError] = useState(null);\n  const [_peerConnections, _setPeerConnections] = useState({});\n  const [iceServers, setIceServers] = useState([]);\n\n  // Refs\n  const peerConnectionRef = useRef(null);\n  const dataChannelRef = useRef(null);\n  const offerIntervalRef = useRef(null);\n  const answerIntervalRef = useRef(null);\n  const candidateIntervalRef = useRef(null);\n  const isMountedRef = useRef(true);\n\n  // Initialize ICE servers\n  useEffect(() => {\n    // Use TURN server configuration by default for better connectivity\n    const servers = getIceServers(config?.useTurn !== false); // Default to true unless explicitly disabled\n    setIceServers(servers);\n  }, [config]);\n\n  // Send ICE candidate\n  const sendICECandidate = useCallback(\n    async (candidate) => {\n      if (!roomId || !role) return;\n\n      try {\n        const response = await fetch('/api/candidate', {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            ...(config?.authSecret && { 'x-auth-secret': config.authSecret }),\n          },\n          body: JSON.stringify({\n            roomId,\n            role,\n            viewerId: _viewerId, // Include viewer ID for proper identification\n            candidate: {\n              candidate: candidate.candidate,\n              sdpMid: candidate.sdpMid,\n              sdpMLineIndex: candidate.sdpMLineIndex,\n            },\n          }),\n        });\n\n        if (!response.ok) {\n          throw new Error(`Failed to send ICE candidate: ${response.status}`);\n        }\n      } catch (err) {\n        logger.error('Error sending ICE candidate:', err);\n        setError(`Failed to send ICE candidate: ${err.message}`);\n      }\n    },\n    [roomId, role, config, _viewerId] // Fixed: Added _viewerId to dependency array\n  );\n\n  // Create peer connection\n  const createPeerConnection = useCallback(() => {\n    const pc = new RTCPeerConnection({\n      iceServers,\n    });\n\n    // Handle ICE candidates\n    pc.onicecandidate = (event) => {\n      if (event.candidate) {\n        sendICECandidate(event.candidate);\n      }\n    };\n\n    // Handle connection state changes\n    pc.onconnectionstatechange = () => {\n      logger.webrtc('Connection state changed', { state: pc.connectionState });\n      setConnectionState(pc.connectionState);\n\n      // Clear polling intervals when connected or failed\n      if (pc.connectionState === 'connected' || pc.connectionState === 'failed') {\n        if (offerIntervalRef.current) {\n          clearInterval(offerIntervalRef.current);\n          offerIntervalRef.current = null;\n        }\n        if (answerIntervalRef.current) {\n          clearInterval(answerIntervalRef.current);\n          answerIntervalRef.current = null;\n        }\n        if (candidateIntervalRef.current) {\n          clearInterval(candidateIntervalRef.current);\n          candidateIntervalRef.current = null;\n        }\n      }\n    };\n\n    // Handle ICE connection state changes\n    pc.oniceconnectionstatechange = () => {\n      logger.webrtc('ICE connection state changed', { state: pc.iceConnectionState });\n    };\n\n    // Handle remote stream\n    pc.ontrack = (event) => {\n      logger.webrtc('Received remote stream', { stream: event.streams[0] });\n      setRemoteStream(event.streams[0]);\n    };\n\n    // Handle data channel\n    pc.ondatachannel = (event) => {\n      const channel = event.channel;\n      dataChannelRef.current = channel;\n\n      channel.onopen = () => {\n        logger.webrtc('Data channel opened');\n      };\n\n      channel.onmessage = (event) => {\n        logger.webrtc('Received data channel message', { data: event.data });\n      };\n    };\n\n    return pc;\n  }, [iceServers, sendICECandidate]);\n\n  // Send offer\n  const sendOffer = useCallback(\n    async (offer) => {\n      if (!roomId) return;\n\n      try {\n        const response = await fetch('/api/offer', {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            ...(config?.authSecret && { 'x-auth-secret': config.authSecret }),\n          },\n          body: JSON.stringify({\n            roomId,\n            desc: offer,\n          }),\n        });\n\n        if (!response.ok) {\n          throw new Error(`Failed to send offer: ${response.status}`);\n        }\n      } catch (err) {\n        logger.error('Error sending offer:', err);\n        setError(`Failed to send offer: ${err.message}`);\n      }\n    },\n    [roomId, config]\n  );\n\n  // Send answer\n  const sendAnswer = useCallback(\n    async (answer) => {\n      if (!roomId) return;\n\n      try {\n        const response = await fetch('/api/answer', {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            ...(config?.authSecret && { 'x-auth-secret': config.authSecret }),\n          },\n          body: JSON.stringify({\n            roomId,\n            desc: answer,\n          }),\n        });\n\n        if (!response.ok) {\n          throw new Error(`Failed to send answer: ${response.status}`);\n        }\n      } catch (err) {\n        logger.error('Error sending answer:', err);\n        setError(`Failed to send answer: ${err.message}`);\n      }\n    },\n    [roomId, config]\n  );\n\n  // Start polling for offers (viewer)\n  const startOfferPolling = useCallback(async () => {\n    if (offerIntervalRef.current) {\n      clearInterval(offerIntervalRef.current);\n    }\n\n    let pollCount = 0;\n    let pollInterval = 1000; // Start with 1 second\n    const maxPolls = 60; // 60 seconds timeout\n\n    const pollForOffer = async () => {\n      try {\n        pollCount++;\n\n        // Timeout after maxPolls attempts\n        if (pollCount > maxPolls) {\n          clearInterval(offerIntervalRef.current);\n          offerIntervalRef.current = null;\n          if (isMountedRef.current) {\n            setError('Connection timeout: No offer received from host. Make sure the host has started sharing.');\n            setConnectionState('failed');\n          }\n          return;\n        }\n\n        const response = await fetch(`/api/offer?roomId=${roomId}`);\n\n        if (response.ok) {\n          const data = await response.json();\n          if (data.desc) {\n            // Clear interval once we get an offer\n            clearInterval(offerIntervalRef.current);\n            offerIntervalRef.current = null;\n\n            // Create peer connection when we receive an offer\n            const pc = createPeerConnection();\n            peerConnectionRef.current = pc;\n\n            // Handle the offer\n            await pc.setRemoteDescription(data.desc);\n\n            // Create and send answer\n            const answer = await pc.createAnswer();\n            await pc.setLocalDescription(answer);\n            await sendAnswer(answer);\n\n            // Start ICE candidate polling now that we have a peer connection\n            startCandidatePolling();\n          }\n        } else if (response.status === 404) {\n          // Expected 404 - no offer yet, but reduce polling frequency after initial attempts\n          if (pollCount > 10) {\n            // After 10 seconds, reduce to polling every 5 seconds\n            clearInterval(offerIntervalRef.current);\n            pollInterval = 5000;\n            offerIntervalRef.current = setInterval(pollForOffer, pollInterval);\n          }\n        } else {\n          // Unexpected error\n          logger.error('Unexpected error polling for offers:', response.status);\n          clearInterval(offerIntervalRef.current);\n          offerIntervalRef.current = null;\n          if (isMountedRef.current) {\n            setError(`Server error: ${response.status}`);\n            setConnectionState('failed');\n          }\n        }\n      } catch (err) {\n        logger.error('Error polling for offers:', err);\n        clearInterval(offerIntervalRef.current);\n        offerIntervalRef.current = null;\n        if (isMountedRef.current) {\n          setError(`Network error: ${err.message}`);\n          setConnectionState('failed');\n        }\n      }\n    };\n\n    offerIntervalRef.current = setInterval(pollForOffer, pollInterval);\n  }, [roomId, sendAnswer, createPeerConnection, startCandidatePolling]);\n\n  // Start polling for answers (host)\n  const startAnswerPolling = useCallback(async () => {\n    if (answerIntervalRef.current) {\n      clearInterval(answerIntervalRef.current);\n    }\n\n    let pollCount = 0;\n    let pollInterval = 1000; // Start with 1 second\n    const maxPolls = 60; // 60 seconds timeout\n\n    const pollForAnswer = async () => {\n      try {\n        pollCount++;\n\n        // Timeout after maxPolls attempts\n        if (pollCount > maxPolls) {\n          clearInterval(answerIntervalRef.current);\n          answerIntervalRef.current = null;\n          if (isMountedRef.current) {\n            setError('Connection timeout: No answer received from viewer. Make sure the viewer has connected.');\n            setConnectionState('failed');\n          }\n          return;\n        }\n\n        const response = await fetch(`/api/answer?roomId=${roomId}`);\n\n        if (response.ok) {\n          const data = await response.json();\n          if (data.desc) {\n            // Clear interval once we get an answer\n            clearInterval(answerIntervalRef.current);\n            answerIntervalRef.current = null;\n\n            // Handle the answer\n            const pc = peerConnectionRef.current;\n            if (pc) {\n              await pc.setRemoteDescription(data.desc);\n            }\n          }\n        } else if (response.status === 404) {\n          // Expected 404 - no answer yet, but reduce polling frequency after initial attempts\n          if (pollCount > 10) {\n            // After 10 seconds, reduce to polling every 5 seconds\n            clearInterval(answerIntervalRef.current);\n            pollInterval = 5000;\n            answerIntervalRef.current = setInterval(pollForAnswer, pollInterval);\n          }\n        } else {\n          // Unexpected error\n          logger.error('Unexpected error polling for answers:', response.status);\n          clearInterval(answerIntervalRef.current);\n          answerIntervalRef.current = null;\n          if (isMountedRef.current) {\n            setError(`Server error: ${response.status}`);\n            setConnectionState('failed');\n          }\n        }\n      } catch (err) {\n        logger.error('Error polling for answers:', err);\n        clearInterval(answerIntervalRef.current);\n        answerIntervalRef.current = null;\n        if (isMountedRef.current) {\n          setError(`Network error: ${err.message}`);\n          setConnectionState('failed');\n        }\n      }\n    };\n\n    answerIntervalRef.current = setInterval(pollForAnswer, pollInterval);\n  }, [roomId]);\n\n  // Start polling for ICE candidates\n  const startCandidatePolling = useCallback(async () => {\n    if (candidateIntervalRef.current) {\n      clearInterval(candidateIntervalRef.current);\n    }\n\n    let pollCount = 0;\n    const maxPolls = 120; // 2 minutes timeout for ICE candidates\n\n    candidateIntervalRef.current = setInterval(async () => {\n      try {\n        pollCount++;\n\n        // Timeout after maxPolls attempts\n        if (pollCount > maxPolls) {\n          clearInterval(candidateIntervalRef.current);\n          candidateIntervalRef.current = null;\n          logger.warn('ICE candidate polling timeout - connection may be stuck');\n          return;\n        }\n\n        const response = await fetch(\n          `/api/candidate?roomId=${roomId}&role=${role}${_viewerId ? `&viewerId=${_viewerId}` : ''}`\n        );\n\n        if (response.ok) {\n          const data = await response.json();\n          if (data.candidates && data.candidates.length > 0) {\n            const pc = peerConnectionRef.current;\n            if (pc) {\n              for (const candidate of data.candidates) {\n                try {\n                  await pc.addIceCandidate(candidate);\n                } catch (candidateErr) {\n                  logger.warn('Failed to add ICE candidate:', candidateErr);\n                }\n              }\n            }\n          }\n        } else if (response.status !== 404) {\n          // 404 is expected when no candidates, but other errors are concerning\n          logger.error('Error polling for ICE candidates:', response.status);\n        }\n      } catch (err) {\n        logger.error('Error polling for ICE candidates:', err);\n      }\n    }, 1000);\n  }, [roomId, role, _viewerId]); // Fixed: Added _viewerId to dependency array\n\n  // Start screen sharing (host)\n  const startScreenShare = useCallback(async () => {\n    if (role !== 'host') {\n      throw new Error('Only hosts can start screen sharing');\n    }\n\n    try {\n      setError(null);\n      setConnectionState('connecting');\n\n      // Get screen share stream\n      const stream = await navigator.mediaDevices.getDisplayMedia({\n        video: true,\n        audio: true,\n      });\n\n      setLocalStream(stream);\n\n      // Create peer connection\n      const pc = createPeerConnection();\n      peerConnectionRef.current = pc;\n\n      // Add stream to peer connection\n      stream.getTracks().forEach((track) => {\n        pc.addTrack(track, stream);\n      });\n\n      // Create and send offer\n      const offer = await pc.createOffer({\n        offerToReceiveAudio: true,\n        offerToReceiveVideo: true,\n      });\n\n      await pc.setLocalDescription(offer);\n      await sendOffer(offer);\n\n      // Start polling for answers\n      startAnswerPolling();\n\n      // Start polling for ICE candidates\n      startCandidatePolling();\n\n      return stream;\n    } catch (err) {\n      logger.error('Error starting screen share:', err);\n      setError(`Failed to start screen sharing: ${err.message}`);\n      setConnectionState('disconnected');\n      throw err;\n    }\n  }, [role, createPeerConnection, sendOffer, startAnswerPolling, startCandidatePolling]);\n\n  // Connect to host (viewer)\n  const connectToHost = useCallback(async () => {\n    if (role !== 'viewer') {\n      throw new Error('Only viewers can connect to host');\n    }\n\n    try {\n      setError(null);\n      setConnectionState('connecting');\n\n      // Don't create peer connection yet - wait for offer from host\n      // Start polling for offers (ICE candidate polling will start when peer connection is created)\n      startOfferPolling();\n    } catch (err) {\n      logger.error('Error connecting to host:', err);\n      setError(`Failed to connect to host: ${err.message}`);\n      setConnectionState('disconnected');\n      throw err;\n    }\n  }, [role, startOfferPolling]);\n\n  // Stop screen sharing\n  const stopScreenShare = useCallback(async () => {\n    try {\n      // Stop local stream\n      if (localStream) {\n        localStream.getTracks().forEach((track) => track.stop());\n        setLocalStream(null);\n      }\n\n      // Close peer connection\n      if (peerConnectionRef.current) {\n        peerConnectionRef.current.close();\n        peerConnectionRef.current = null;\n      }\n\n      // Clear intervals\n      if (offerIntervalRef.current) {\n        clearInterval(offerIntervalRef.current);\n        offerIntervalRef.current = null;\n      }\n\n      if (answerIntervalRef.current) {\n        clearInterval(answerIntervalRef.current);\n        answerIntervalRef.current = null;\n      }\n\n      if (candidateIntervalRef.current) {\n        clearInterval(candidateIntervalRef.current);\n        candidateIntervalRef.current = null;\n      }\n\n      setConnectionState('disconnected');\n      setRemoteStream(null);\n    } catch (err) {\n      logger.error('Error stopping screen share:', err);\n      setError(`Failed to stop screen sharing: ${err.message}`);\n    }\n  }, [localStream]);\n\n  // Disconnect\n  const disconnect = useCallback(async () => {\n    await stopScreenShare();\n  }, [stopScreenShare]);\n\n  // Start polling for offers (viewer)\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      isMountedRef.current = false; // Mark component as unmounted\n\n      if (offerIntervalRef.current) {\n        clearInterval(offerIntervalRef.current);\n      }\n      if (answerIntervalRef.current) {\n        clearInterval(answerIntervalRef.current);\n      }\n      if (candidateIntervalRef.current) {\n        clearInterval(candidateIntervalRef.current);\n      }\n      if (peerConnectionRef.current) {\n        peerConnectionRef.current.close();\n      }\n      if (localStream) {\n        localStream.getTracks().forEach((track) => track.stop());\n      }\n    };\n  }, [localStream]);\n\n  return {\n    // State\n    connectionState,\n    remoteStream,\n    localStream,\n    error,\n    peerConnections: _peerConnections,\n\n    // Actions\n    startScreenShare,\n    stopScreenShare,\n    connectToHost,\n    disconnect,\n  };\n}\n"],"names":["VideoPlayer","forwardRef","className","props","ref","videoRef","useRef","internalRef","useImperativeHandle","useEffect","video","handleLoadedMetadata","handleLoadedData","handleCanPlay","handlePlay","handlePause","handleEnded","handleError","e","handleWaiting","handleStalled","jsx","DEFAULT_STUN_SERVERS","TURN_SERVERS","define_process_env_default","getIceServers","includeTurn","iceServers","isDevelopment","LOG_LEVELS","currentLogLevel","Logger","message","args","event","data","method","endpoint","action","logger","useWebRTC","roomId","role","config","_viewerId","connectionState","setConnectionState","useState","remoteStream","setRemoteStream","localStream","setLocalStream","error","setError","_peerConnections","_setPeerConnections","setIceServers","peerConnectionRef","dataChannelRef","offerIntervalRef","answerIntervalRef","candidateIntervalRef","isMountedRef","servers","sendICECandidate","useCallback","candidate","response","err","createPeerConnection","pc","channel","sendOffer","offer","sendAnswer","answer","startOfferPolling","pollCount","pollInterval","maxPolls","pollForOffer","startCandidatePolling","startAnswerPolling","pollForAnswer","candidateErr","startScreenShare","stream","track","connectToHost","stopScreenShare","disconnect"],"mappings":"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"}