import{r as s,j as ne}from"./main-CaOUFGsb.js";const re=s.forwardRef(({className:l,...r},c)=>{const h=s.useRef(null),T=c||h;return s.useImperativeHandle(c,()=>h.current,[]),s.useEffect(()=>{const a=T.current;if(!a)return;const g=()=>{console.log("Video metadata loaded:",{duration:a.duration,videoWidth:a.videoWidth,videoHeight:a.videoHeight})},N=()=>{console.log("Video data loaded")},C=()=>{console.log("Video can start playing")},R=()=>{console.log("Video started playing")},v=()=>{console.log("Video paused")},m=()=>{console.log("Video ended")},I=_=>{console.error("Video error:",_)},L=()=>{console.log("Video waiting for data")},E=()=>{console.log("Video stalled")};return a.addEventListener("loadedmetadata",g),a.addEventListener("loadeddata",N),a.addEventListener("canplay",C),a.addEventListener("play",R),a.addEventListener("pause",v),a.addEventListener("ended",m),a.addEventListener("error",I),a.addEventListener("waiting",L),a.addEventListener("stalled",E),()=>{a.removeEventListener("loadedmetadata",g),a.removeEventListener("loadeddata",N),a.removeEventListener("canplay",C),a.removeEventListener("play",R),a.removeEventListener("pause",v),a.removeEventListener("ended",m),a.removeEventListener("error",I),a.removeEventListener("waiting",L),a.removeEventListener("stalled",E)}},[T]),ne.jsx("video",{ref:T,className:l,"aria-label":"Screen sharing video stream",...r})});re.displayName="VideoPlayer";var J={};const ae=[{urls:"stun:stun.l.google.com:19302"},{urls:"stun:stun1.l.google.com:19302"},{urls:"stun:stun2.l.google.com:19302"},{urls:"stun:stun3.l.google.com:19302"},{urls:"stun:stun4.l.google.com:19302"}],K=[{urls:"turn:openrelay.metered.ca:80",username:"openrelayproject",credential:"openrelayproject"},{urls:"turn:openrelay.metered.ca:443",username:"openrelayproject",credential:"openrelayproject"},{urls:"turn:openrelay.metered.ca:443?transport=tcp",username:"openrelayproject",credential:"openrelayproject"},...J.TURN_SERVERS?(()=>{try{return JSON.parse(J.TURN_SERVERS)}catch(l){return console.error("Invalid TURN_SERVERS JSON:",l),[]}})():[]];function q(l=!1){const r=[...ae];return l&&K.length>0&&r.push(...K),r}const x=window.location.hostname==="localhost"||window.location.hostname.includes("localhost"),k={ERROR:0,WARN:1,INFO:2,DEBUG:3},U=x?k.DEBUG:k.ERROR;class o{static error(r,...c){U>=k.ERROR&&console.error(`[ERROR] ${r}`,...c)}static warn(r,...c){U>=k.WARN&&console.warn(`[WARN] ${r}`,...c)}static info(r,...c){U>=k.INFO&&console.info(`[INFO] ${r}`,...c)}static debug(r,...c){U>=k.DEBUG&&console.debug(`[DEBUG] ${r}`,...c)}static webrtc(r,c={}){x&&console.debug(`[WebRTC] ${r}`,c)}static api(r,c,h={}){x&&console.debug(`[API] ${r} ${c}`,h)}static user(r,c={}){x&&console.debug(`[USER] ${r}`,c)}}const le={DISCONNECTED:"disconnected",CONNECTING:"connecting",CONNECTED:"connected"},de={ROOM_NOT_FOUND:"Room not found. Please check the room ID and make sure the host has started sharing.",CONNECTION_FAILED:"Failed to connect to host. Please check the room ID and try again.",SCREEN_SHARE_FAILED:"Failed to start screen sharing. Please check your browser permissions.",INVALID_ROOM_ID:"Room ID must be exactly 24 characters and contain only letters and numbers",INVALID_VIEWER_ID:"Viewer ID can only contain letters, numbers, spaces, hyphens, and underscores",CONNECTION_TIMEOUT:"Connection timeout. Please try again."},ue={CONNECT_TO_HOST:"Connect to Host",DISCONNECT:"Disconnect",RECONNECT:"Reconnect",CONNECTING:"Connecting...",CONNECTED:"Connected",DISCONNECTED:"Disconnected",HOST_ONLINE:"Host Online",HOST_OFFLINE:"Host Offline",CONNECTING_TO_HOST:"Connecting to Host...",UNKNOWN:"Unknown"},fe={SUCCESS:"text-green-600",WARNING:"text-yellow-600",ERROR:"text-red-600",DEFAULT:"text-gray-600"},oe={DEFAULT:1e3},Ee={CONFIG:"/api/config",CREATE_ROOM:"/api/create-room",OFFER:"/api/offer",ANSWER:"/api/answer",CANDIDATE:"/api/candidate",CHAT:"/api/chat",DIAGNOSTICS:"/api/diagnostics",VIEWERS:"/api/viewers",REGISTER_SENDER:"/api/register-sender"};function M(l,r={}){const{initialInterval:c=oe.DEFAULT,maxInterval:h=3e4,backoffFactor:T=1.5,maxPolls:a=60,backoffAfter:g=10}=r;return async()=>{let N=0,C=c;const R=async()=>{if(N++,N>a)throw new Error("Polling timeout reached");const v=await l();return v||(N>g&&(C=Math.min(C*T,h)),new Promise((m,I)=>{const L=setTimeout(async()=>{try{const E=await R();m(E)}catch(E){I(E)}},C);R.timeoutId=L}))};return R()}}function he(l,r,c,h=null){const[T,a]=s.useState("disconnected"),[g,N]=s.useState(null),[C,R]=s.useState(null),[v,m]=s.useState(null),[I,L]=s.useState([]),[E,_]=s.useState(null),[X,se]=s.useState(new Map),[Y,ce]=s.useState(0),[z,A]=s.useState({type:null,code:null,message:null,details:null}),d=s.useRef(null),Q=s.useRef(null),w=s.useRef(null),S=s.useRef(null),y=s.useRef(null),F=s.useRef(!0),O=s.useRef(null);s.useEffect(()=>{const t=q(c?.useTurn!==!1);L(t)},[c]);const i=s.useCallback((t,e,n,u=null)=>{A({type:t,code:e,message:n,details:u}),m(n),o.error(`WebRTC Error [${t}]: ${n}`,{code:e,details:u})},[]),b=s.useCallback(async()=>{if(!l||!r)return null;try{const t=r==="viewer"&&h?h:r,e=await fetch("/api/register-sender",{method:"POST",headers:{"Content-Type":"application/json",...c?.authSecret&&{"x-auth-secret":c.authSecret}},body:JSON.stringify({roomId:l,senderId:t})});if(!e.ok)throw new Error(`Failed to register sender: ${e.status}`);return(await e.json()).secret}catch(t){return o.error("Error registering sender:",t),null}},[l,r,h,c]),$=s.useCallback(async t=>{if(!(!l||!r))try{const e=await fetch("/api/candidate",{method:"POST",headers:{"Content-Type":"application/json",...c?.authSecret&&{"x-auth-secret":c.authSecret},...E&&{"x-sender-secret":E}},body:JSON.stringify({roomId:l,role:r,viewerId:h,candidate:t})});if(!e.ok)throw new Error(`Failed to send ICE candidate: ${e.status}`)}catch(e){o.error("Error sending ICE candidate:",e),i("network","SEND_ICE_CANDIDATE_FAILED","Failed to send ICE candidate to server. Please check your connection and try again.",e.message)}},[l,r,c,h,i,E]),P=s.useCallback(()=>{const t=I.length>0?I:q(!0),e=new RTCPeerConnection({iceServers:t});return e.onicecandidate=n=>{if(n.candidate)try{n.candidate.candidate&&n.candidate.sdpMid!==void 0&&n.candidate.sdpMLineIndex!==void 0?$(n.candidate):o.warn("Invalid ICE candidate received, skipping:",n.candidate)}catch(u){o.error("Error handling ICE candidate:",u)}},e.onicegatheringstatechange=()=>{o.webrtc("ICE gathering state changed",{state:e.iceGatheringState}),e.iceGatheringState==="complete"&&i("webrtc","ICE_GATHERING_TIMEOUT","Failed to send offer - no ICE candidates generated for network connection","ICE gathering completed without generating any candidates")},e.onconnectionstatechange=()=>{o.webrtc("Connection state changed",{state:e.connectionState}),a(e.connectionState),e.connectionState==="connected"&&(m(null),A({type:null,code:null,message:null,details:null})),(e.connectionState==="connected"||e.connectionState==="failed")&&(w.current&&(clearInterval(w.current),w.current=null),S.current&&(clearInterval(S.current),S.current=null),y.current&&(clearInterval(y.current),y.current=null)),(e.connectionState==="disconnected"||e.connectionState==="failed"||e.connectionState==="closed")&&setTimeout(()=>{if(d.current===e)try{e.close(),d.current=null}catch(n){o.error("Error during peer connection cleanup:",n)}},0)},e.oniceconnectionstatechange=()=>{o.webrtc("ICE connection state changed",{state:e.iceConnectionState}),e.iceConnectionState==="failed"&&(a("failed"),i("webrtc","ICE_CONNECTION_FAILED","Connection failed - unable to establish network connection",`ICE connection state: ${e.iceConnectionState}`),setTimeout(()=>{if(d.current===e)try{e.close(),d.current=null}catch(n){o.error("Error during peer connection cleanup on ICE failure:",n)}},0))},e.ontrack=n=>{o.webrtc("Received remote stream",{stream:n.streams[0]}),N(n.streams[0])},e.ondatachannel=n=>{const u=n.channel;Q.current=u,u.onopen=()=>{o.webrtc("Data channel opened")},u.onmessage=f=>{o.webrtc("Received data channel message",{data:f.data})}},e},[I,$,i]),W=s.useCallback(async t=>{if(l)try{const e=await fetch("/api/offer",{method:"POST",headers:{"Content-Type":"application/json",...c?.authSecret&&{"x-auth-secret":c.authSecret},...E&&{"x-sender-secret":E}},body:JSON.stringify({roomId:l,desc:t,role:r})});if(!e.ok)throw new Error(`Failed to send offer: ${e.status}`)}catch(e){throw o.error("Error sending offer:",e),i("network","SEND_OFFER_FAILED","Failed to send offer to server. Please check your connection and try again.",e.message),e}},[l,c,i,E,r]),j=s.useCallback(async t=>{if(l)try{const e=await fetch("/api/answer",{method:"POST",headers:{"Content-Type":"application/json",...c?.authSecret&&{"x-auth-secret":c.authSecret},...E&&{"x-sender-secret":E}},body:JSON.stringify({roomId:l,desc:t,role:r})});if(!e.ok)throw new Error(`Failed to send answer: ${e.status}`)}catch(e){throw o.error("Error sending answer:",e),i("network","SEND_ANSWER_FAILED","Failed to send answer to server. Please check your connection and try again.",e.message),e}},[l,c,i,E,r]),V=s.useCallback(async()=>{y.current&&clearInterval(y.current);const e=M(async()=>{try{const n=await fetch(`/api/candidate?roomId=${l}&role=${r}${h?`&viewerId=${h}`:""}`);if(n.ok){const u=await n.json();if(u.candidates&&u.candidates.length>0){const f=d.current;if(f)for(const p of u.candidates)try{p&&typeof p=="object"&&p.candidate&&p.sdpMid!==void 0&&p.sdpMLineIndex!==void 0?(await f.addIceCandidate(p),o.webrtc("Added ICE candidate",{candidate:p})):o.warn("Invalid ICE candidate received, skipping:",p)}catch(D){o.error("Error adding ICE candidate:",D)}return!0}}else return n.status===404?!1:(o.error("Error polling for ICE candidates:",n.status),!0);return!1}catch(n){return o.error("Network error polling for ICE candidates:",n),!1}},{initialInterval:1e3,maxInterval:5e3,maxPolls:30});try{await e()}catch(n){o.error("ICE candidate polling timeout:",n),F.current&&i("timeout","ICE_CANDIDATE_POLLING_TIMEOUT","ICE candidate polling timeout - connection may be unstable",n.message)}},[l,r,h,i]),H=s.useCallback(async()=>{w.current&&(clearInterval(w.current),w.current=null);const e=M(async()=>{try{const n=await fetch(`/api/offer?roomId=${l}`);if(n.ok){const u=await n.json();if(u.desc){const f=P();d.current=f,await f.setRemoteDescription(u.desc);const p=await f.createAnswer();return await f.setLocalDescription(p),await j(p),V(),!0}}return!1}catch(n){return o.error("Network error while polling for offer:",n),!1}},{maxPolls:15});try{await e()}catch(n){o.error("Offer polling timed out.",n),F.current&&(i("timeout","OFFER_POLLING_TIMEOUT","Connection timeout: No offer received from host. Make sure the host has started sharing.",n.message),a("failed"))}},[l,j,P,V,i]),B=s.useCallback(async()=>{S.current&&(clearInterval(S.current),S.current=null);const e=M(async()=>{try{const n=await fetch(`/api/answer?roomId=${l}`);if(n.ok){const u=await n.json();if(u.desc){const f=d.current;return f&&await f.setRemoteDescription(u.desc),!0}}return!1}catch(n){return o.error("Network error while polling for answer:",n),!1}},{maxPolls:15});try{await e()}catch(n){o.error("Answer polling timed out.",n),F.current&&(i("timeout","ANSWER_POLLING_TIMEOUT","Connection timeout: No answer received from viewer. Make sure the viewer has connected.",n.message),a("failed"))}},[l,i]),Z=s.useCallback(async()=>{if(r!=="host")throw new Error("Only hosts can start screen sharing");try{m(null),a("connecting");const t=await b();t&&_(t);const e=await navigator.mediaDevices.getDisplayMedia({video:!0,audio:!0}),n=e.getVideoTracks(),u=e.getAudioTracks();if(n.length===0)throw i("permission","VIDEO_DENIED","Video permission is required to share your screen. Please allow video access and try again.","User denied video permission in getDisplayMedia"),new Error("Video permission denied - cannot share screen without video");u.length===0&&o.warn("Audio permission denied - screen sharing will be video-only"),R(e),O.current=e;const f=P();d.current=f,e.getTracks().forEach(D=>{f.addTransceiver(D,{streams:[e],direction:"sendonly"})});const p=await f.createOffer({offerToReceiveAudio:!0,offerToReceiveVideo:!0});return await f.setLocalDescription(p),await W(p),B().catch(D=>{o.error("Answer polling failed:",D)}),V().catch(D=>{o.error("ICE candidate polling failed:",D)}),e}catch(t){if(o.error("Error starting screen share:",t),a("failed"),O.current&&(O.current.getTracks().forEach(e=>e.stop()),O.current=null,R(null)),d.current)try{d.current.close(),d.current=null}catch(e){o.error("Error during peer connection cleanup:",e)}throw t.name==="NotAllowedError"||t.message.includes("Permission denied")?i("permission","PERMISSION_DENIED","Screen sharing permission was denied. Please allow permission and try again.",t.message):t.name==="NotFoundError"?i("permission","NO_DISPLAY_AVAILABLE","No display available for screen sharing. Please ensure you have a screen to share.",t.message):t.name==="AbortError"?i("permission","SHARING_CANCELLED","Screen sharing was cancelled. Please try again.",t.message):t.message.includes("createOffer")?i("webrtc","CREATE_OFFER_FAILED","Failed to create WebRTC offer. Please try again.",t.message):t.message.includes("setLocalDescription")?i("webrtc","SET_LOCAL_DESCRIPTION_FAILED","Failed to set local description. Please try again.",t.message):t.message.includes("Failed to send offer")?i("network","SEND_OFFER_FAILED","Failed to send offer to server. Please check your connection and try again.",t.message):i("unknown","UNKNOWN_ERROR","An unexpected error occurred. Please try again.",t.message),t}},[r,P,W,B,V,i,O,b]),ee=s.useCallback(async()=>{if(r!=="viewer")throw new Error("Only viewers can connect to host");try{m(null),a("connecting");const t=await b();t&&_(t),H()}catch(t){if(o.error("Error connecting to host:",t),a("failed"),d.current)try{d.current.close(),d.current=null}catch(e){o.error("Error during peer connection cleanup:",e)}throw t.message.includes("Network error")||t.message.includes("fetch")?i("network","NETWORK_ERROR","Network connection failed. Please check your connection and try again.",t.message):t.message.includes("Room not found")||t.message.includes("404")?i("network","ROOM_NOT_FOUND","Room not found. Please check the room ID and try again.",t.message):i("unknown","UNKNOWN_ERROR","An unexpected error occurred. Please try again.",t.message),t}},[r,H,i,b]),G=s.useCallback(async()=>{try{if(C&&(C.getTracks().forEach(t=>t.stop()),R(null),O.current=null),g&&(g.getTracks().forEach(t=>t.stop()),N(null)),d.current)try{d.current.close(),d.current=null}catch(t){o.error("Error closing peer connection:",t)}w.current&&(clearInterval(w.current),w.current=null),S.current&&(clearInterval(S.current),S.current=null),y.current&&(clearInterval(y.current),y.current=null),a("disconnected"),N(null),m(null),A({type:null,code:null,message:null,details:null})}catch(t){o.error("Error stopping screen share:",t),m(`Failed to stop screen sharing: ${t.message}`)}},[C,g]),te=s.useCallback(async()=>{await G()},[G]);return s.useEffect(()=>()=>{if(F.current=!1,w.current&&(clearInterval(w.current),w.current=null),S.current&&(clearInterval(S.current),S.current=null),y.current&&(clearInterval(y.current),y.current=null),d.current)try{d.current.close(),d.current=null}catch(e){o.error("Error during peer connection cleanup on unmount:",e)}const t=O.current;t&&(t.getTracks().forEach(e=>e.stop()),O.current=null),g&&g.getTracks().forEach(e=>e.stop()),m(null),A({type:null,code:null,message:null,details:null}),a("disconnected")},[g]),{connectionState:T,remoteStream:g,localStream:C,error:v,errorState:z,peerConnections:X,viewerCount:Y,startScreenShare:Z,stopScreenShare:G,connectToHost:ee,disconnect:te}}export{Ee as A,le as C,de as E,fe as S,ue as U,re as V,he as u};
//# sourceMappingURL=useWebRTC-CxxzCBjY.js.map
