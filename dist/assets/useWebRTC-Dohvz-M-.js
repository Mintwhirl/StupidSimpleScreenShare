import{r,j as M}from"./main-BOm-zLcm.js";const W=r.forwardRef(({className:a,...l},i)=>{const T=r.useRef(null),v=i||T;return r.useEffect(()=>{const n=v.current;if(!n)return;const S=()=>{console.log("Video metadata loaded:",{duration:n.duration,videoWidth:n.videoWidth,videoHeight:n.videoHeight})},g=()=>{console.log("Video data loaded")},u=()=>{console.log("Video can start playing")},E=()=>{console.log("Video started playing")},m=()=>{console.log("Video paused")},d=()=>{console.log("Video ended")},C=k=>{console.error("Video error:",k)},L=()=>{console.log("Video waiting for data")},w=()=>{console.log("Video stalled")};return n.addEventListener("loadedmetadata",S),n.addEventListener("loadeddata",g),n.addEventListener("canplay",u),n.addEventListener("play",E),n.addEventListener("pause",m),n.addEventListener("ended",d),n.addEventListener("error",C),n.addEventListener("waiting",L),n.addEventListener("stalled",w),()=>{n.removeEventListener("loadedmetadata",S),n.removeEventListener("loadeddata",g),n.removeEventListener("canplay",u),n.removeEventListener("play",E),n.removeEventListener("pause",m),n.removeEventListener("ended",d),n.removeEventListener("error",C),n.removeEventListener("waiting",L),n.removeEventListener("stalled",w)}},[v]),M.jsx("video",{ref:v,className:a,...l})});W.displayName="VideoPlayer";var _={};const H=[{urls:"stun:stun.l.google.com:19302"},{urls:"stun:stun1.l.google.com:19302"},{urls:"stun:stun2.l.google.com:19302"},{urls:"stun:stun3.l.google.com:19302"},{urls:"stun:stun4.l.google.com:19302"}],D=[{urls:"turn:your-turn-server.com:3478",username:_.TURN_USERNAME||"your-username",credential:_.TURN_PASSWORD||"your-password"}];function J(a=!1){const l=[...H];return a&&D.length>0&&l.push(...D),l}function z(a,l,i,T=null){const[v,n]=r.useState("disconnected"),[S,g]=r.useState(null),[u,E]=r.useState(null),[m,d]=r.useState(null),[C,L]=r.useState({}),[w,k]=r.useState([]),f=r.useRef(null),j=r.useRef(null),s=r.useRef(null),h=r.useRef(null);r.useEffect(()=>{const e=J(i?.useTurn||!1);k(e)},[i]);const b=r.useCallback(async e=>{if(!(!a||!l))try{const t=await fetch("/api/candidate",{method:"POST",headers:{"Content-Type":"application/json",...i?.authSecret&&{"x-auth-secret":i.authSecret}},body:JSON.stringify({roomId:a,role:l,candidate:{candidate:e.candidate,sdpMid:e.sdpMid,sdpMLineIndex:e.sdpMLineIndex}})});if(!t.ok)throw new Error(`Failed to send ICE candidate: ${t.status}`)}catch(t){console.error("Error sending ICE candidate:",t),d(`Failed to send ICE candidate: ${t.message}`)}},[a,l,i]),R=r.useCallback(()=>{const e=new RTCPeerConnection({iceServers:w});return e.onicecandidate=t=>{t.candidate&&b(t.candidate)},e.onconnectionstatechange=()=>{console.log("Connection state changed:",e.connectionState),n(e.connectionState)},e.oniceconnectionstatechange=()=>{console.log("ICE connection state changed:",e.iceConnectionState)},e.ontrack=t=>{console.log("Received remote stream:",t.streams[0]),g(t.streams[0])},e.ondatachannel=t=>{const c=t.channel;j.current=c,c.onopen=()=>{console.log("Data channel opened")},c.onmessage=o=>{console.log("Received data channel message:",o.data)}},e},[w,b]),P=r.useCallback(async e=>{if(a)try{const t=await fetch("/api/offer",{method:"POST",headers:{"Content-Type":"application/json",...i?.authSecret&&{"x-auth-secret":i.authSecret}},body:JSON.stringify({roomId:a,desc:e})});if(!t.ok)throw new Error(`Failed to send offer: ${t.status}`)}catch(t){console.error("Error sending offer:",t),d(`Failed to send offer: ${t.message}`)}},[a,i]),V=r.useCallback(async e=>{if(a)try{const t=await fetch("/api/answer",{method:"POST",headers:{"Content-Type":"application/json",...i?.authSecret&&{"x-auth-secret":i.authSecret}},body:JSON.stringify({roomId:a,desc:e})});if(!t.ok)throw new Error(`Failed to send answer: ${t.status}`)}catch(t){console.error("Error sending answer:",t),d(`Failed to send answer: ${t.message}`)}},[a,i]),O=r.useCallback(async()=>{s.current&&clearInterval(s.current);let e=0,t=1e3;const c=async()=>{try{const o=await fetch(`/api/offer?roomId=${a}`);if(o.ok){const y=await o.json();if(y.desc){clearInterval(s.current),s.current=null;const p=f.current;if(p){await p.setRemoteDescription(y.desc);const F=await p.createAnswer();await p.setLocalDescription(F),await V(F)}}}else o.status===404?(e++,e>10&&(clearInterval(s.current),t=5e3,s.current=setInterval(c,t))):console.error("Unexpected error polling for offers:",o.status)}catch(o){console.error("Error polling for offers:",o)}};s.current=setInterval(c,t)},[a,V]),$=r.useCallback(async()=>{s.current&&clearInterval(s.current);let e=0,t=1e3;const c=async()=>{try{const o=await fetch(`/api/answer?roomId=${a}`);if(o.ok){const y=await o.json();if(y.desc){clearInterval(s.current),s.current=null;const p=f.current;p&&await p.setRemoteDescription(y.desc)}}else o.status===404?(e++,e>10&&(clearInterval(s.current),t=5e3,s.current=setInterval(c,t))):console.error("Unexpected error polling for answers:",o.status)}catch(o){console.error("Error polling for answers:",o)}};s.current=setInterval(c,t)},[a]),x=r.useCallback(async()=>{h.current&&clearInterval(h.current),h.current=setInterval(async()=>{try{const e=await fetch(`/api/candidate?roomId=${a}&role=${l}`);if(e.ok){const t=await e.json();if(t.candidates&&t.candidates.length>0){const c=f.current;if(c)for(const o of t.candidates)await c.addIceCandidate(o)}}}catch(e){console.error("Error polling for ICE candidates:",e)}},1e3)},[a,l]),N=r.useCallback(async()=>{if(l!=="host")throw new Error("Only hosts can start screen sharing");try{d(null),n("connecting");const e=await navigator.mediaDevices.getDisplayMedia({video:!0,audio:!0});E(e);const t=R();f.current=t,e.getTracks().forEach(o=>{t.addTrack(o,e)});const c=await t.createOffer({offerToReceiveAudio:!0,offerToReceiveVideo:!0});return await t.setLocalDescription(c),await P(c),$(),e}catch(e){throw console.error("Error starting screen share:",e),d(`Failed to start screen sharing: ${e.message}`),n("disconnected"),e}},[l,R,P,$]),A=r.useCallback(async()=>{if(l!=="viewer")throw new Error("Only viewers can connect to host");try{d(null),n("connecting");const e=R();f.current=e,O(),x()}catch(e){throw console.error("Error connecting to host:",e),d(`Failed to connect to host: ${e.message}`),n("disconnected"),e}},[l,R,x,O]),I=r.useCallback(async()=>{try{u&&(u.getTracks().forEach(e=>e.stop()),E(null)),f.current&&(f.current.close(),f.current=null),s.current&&(clearInterval(s.current),s.current=null),h.current&&(clearInterval(h.current),h.current=null),n("disconnected"),g(null)}catch(e){console.error("Error stopping screen share:",e),d(`Failed to stop screen sharing: ${e.message}`)}},[u]),U=r.useCallback(async()=>{await I()},[I]);return r.useEffect(()=>()=>{s.current&&clearInterval(s.current),h.current&&clearInterval(h.current),f.current&&f.current.close(),u&&u.getTracks().forEach(e=>e.stop())},[u]),{connectionState:v,remoteStream:S,localStream:u,error:m,peerConnections:C,startScreenShare:N,stopScreenShare:I,connectToHost:A,disconnect:U}}export{W as V,z as u};
//# sourceMappingURL=useWebRTC-Dohvz-M-.js.map
