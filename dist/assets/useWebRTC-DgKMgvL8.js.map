{"version":3,"file":"useWebRTC-DgKMgvL8.js","sources":["../../src/components/VideoPlayer.jsx","../../src/config/turn.js","../../src/utils/logger.js","../../src/constants/index.js","../../src/utils/polling.js","../../src/hooks/useWebRTC.js"],"sourcesContent":["import { forwardRef, useEffect, useRef, useImperativeHandle } from 'react';\n\nconst VideoPlayer = forwardRef(({ className, ...props }, ref) => {\n  const videoRef = useRef(null);\n  const internalRef = ref || videoRef;\n\n  // Use useImperativeHandle to properly handle ref forwarding\n  useImperativeHandle(ref, () => videoRef.current, []);\n\n  // Handle video element events\n  useEffect(() => {\n    const video = internalRef.current;\n    if (!video) return;\n\n    const handleLoadedMetadata = () => {\n      console.log('Video metadata loaded:', {\n        duration: video.duration,\n        videoWidth: video.videoWidth,\n        videoHeight: video.videoHeight,\n      });\n    };\n\n    const handleLoadedData = () => {\n      console.log('Video data loaded');\n    };\n\n    const handleCanPlay = () => {\n      console.log('Video can start playing');\n    };\n\n    const handlePlay = () => {\n      console.log('Video started playing');\n    };\n\n    const handlePause = () => {\n      console.log('Video paused');\n    };\n\n    const handleEnded = () => {\n      console.log('Video ended');\n    };\n\n    const handleError = (e) => {\n      console.error('Video error:', e);\n    };\n\n    const handleWaiting = () => {\n      console.log('Video waiting for data');\n    };\n\n    const handleStalled = () => {\n      console.log('Video stalled');\n    };\n\n    // Add event listeners\n    video.addEventListener('loadedmetadata', handleLoadedMetadata);\n    video.addEventListener('loadeddata', handleLoadedData);\n    video.addEventListener('canplay', handleCanPlay);\n    video.addEventListener('play', handlePlay);\n    video.addEventListener('pause', handlePause);\n    video.addEventListener('ended', handleEnded);\n    video.addEventListener('error', handleError);\n    video.addEventListener('waiting', handleWaiting);\n    video.addEventListener('stalled', handleStalled);\n\n    // Cleanup\n    return () => {\n      video.removeEventListener('loadedmetadata', handleLoadedMetadata);\n      video.removeEventListener('loadeddata', handleLoadedData);\n      video.removeEventListener('canplay', handleCanPlay);\n      video.removeEventListener('play', handlePlay);\n      video.removeEventListener('pause', handlePause);\n      video.removeEventListener('ended', handleEnded);\n      video.removeEventListener('error', handleError);\n      video.removeEventListener('waiting', handleWaiting);\n      video.removeEventListener('stalled', handleStalled);\n    };\n  }, [internalRef]);\n\n  return <video ref={internalRef} className={className} aria-label='Screen sharing video stream' {...props} />;\n});\n\nVideoPlayer.displayName = 'VideoPlayer';\n\nexport default VideoPlayer;\n","/**\n * TURN Server Configuration\n * Provides STUN and TURN servers for WebRTC connections\n */\n\n// Default STUN servers (free, no authentication required)\nconst DEFAULT_STUN_SERVERS = [\n  { urls: 'stun:stun.l.google.com:19302' },\n  { urls: 'stun:stun1.l.google.com:19302' },\n  { urls: 'stun:stun2.l.google.com:19302' },\n  { urls: 'stun:stun3.l.google.com:19302' },\n  { urls: 'stun:stun4.l.google.com:19302' },\n];\n\n// TURN servers (require authentication and may have costs)\nconst TURN_SERVERS = [\n  // Free TURN server for testing (may have limitations)\n  {\n    urls: 'turn:openrelay.metered.ca:80',\n    username: 'openrelayproject',\n    credential: 'openrelayproject',\n  },\n  {\n    urls: 'turn:openrelay.metered.ca:443',\n    username: 'openrelayproject',\n    credential: 'openrelayproject',\n  },\n  {\n    urls: 'turn:openrelay.metered.ca:443?transport=tcp',\n    username: 'openrelayproject',\n    credential: 'openrelayproject',\n  },\n  // Production TURN servers (if configured)\n  ...(process.env.TURN_SERVERS\n    ? (() => {\n        try {\n          return JSON.parse(process.env.TURN_SERVERS);\n        } catch (error) {\n          console.error('Invalid TURN_SERVERS JSON:', error);\n          return [];\n        }\n      })()\n    : []),\n];\n\n/**\n * Get ICE servers configuration for WebRTC\n * @param {boolean} includeTurn - Whether to include TURN servers\n * @returns {Array} Array of ICE server configurations\n */\nexport function getIceServers(includeTurn = false) {\n  const iceServers = [...DEFAULT_STUN_SERVERS];\n\n  if (includeTurn && TURN_SERVERS.length > 0) {\n    iceServers.push(...TURN_SERVERS);\n  }\n\n  return iceServers;\n}\n\n/**\n * Get STUN servers only (for basic connectivity)\n * @returns {Array} Array of STUN server configurations\n */\nexport function getStunServers() {\n  return DEFAULT_STUN_SERVERS;\n}\n\n/**\n * Check if TURN servers are configured\n * @returns {boolean} True if TURN servers are available\n */\nexport function hasTurnServers() {\n  return TURN_SERVERS.length > 0 && process.env.TURN_USERNAME && process.env.TURN_PASSWORD;\n}\n\n/**\n * Get connection quality based on ICE gathering state\n * @param {RTCPeerConnection} peerConnection - The peer connection to check\n * @returns {string} Connection quality ('excellent', 'good', 'poor', 'unknown')\n */\nexport function getConnectionQuality(peerConnection) {\n  if (!peerConnection) return 'unknown';\n\n  // This is a simplified implementation\n  // In a real app, you'd analyze the stats for connection quality\n\n  switch (peerConnection.connectionState) {\n    case 'connected':\n      return 'excellent';\n    case 'connecting':\n      return 'good';\n    case 'disconnected':\n    case 'failed':\n      return 'poor';\n    default:\n      return 'unknown';\n  }\n}\n\n/**\n * Configure WebRTC with optimal settings\n * @param {RTCPeerConnection} peerConnection - The peer connection to configure\n * @param {boolean} useTurn - Whether to use TURN servers\n * @param {string} transportPolicy - ICE transport policy ('all' or 'relay')\n */\nexport function configureWebRTC(peerConnection, useTurn = false, transportPolicy = null) {\n  if (!peerConnection) return;\n\n  // Get transport policy from environment or use default\n  const iceTransportPolicy = transportPolicy || process.env.ICE_TRANSPORT_POLICY || (useTurn ? 'all' : 'all');\n\n  // Set ICE servers\n  peerConnection.setConfiguration({\n    iceServers: getIceServers(useTurn),\n    iceCandidatePoolSize: 10,\n    iceTransportPolicy,\n    bundlePolicy: 'max-bundle',\n    rtcpMuxPolicy: 'require',\n  });\n\n  // Configure ICE gathering\n  peerConnection.addEventListener('icegatheringstatechange', () => {\n    console.log('ICE gathering state:', peerConnection.iceGatheringState);\n  });\n\n  peerConnection.addEventListener('iceconnectionstatechange', () => {\n    console.log('ICE connection state:', peerConnection.iceConnectionState);\n  });\n}\n\nexport default {\n  getIceServers,\n  getStunServers,\n  hasTurnServers,\n  getConnectionQuality,\n  configureWebRTC,\n};\n","/**\n * Logger Utility\n * Centralized logging with environment-aware levels\n */\n\nconst isDevelopment =\n  import.meta.env.DEV ||\n  import.meta.env.MODE === 'development' ||\n  import.meta.env.MODE === 'test' ||\n  window.location.hostname === 'localhost' ||\n  window.location.hostname.includes('localhost');\n\n// const isProduction = import.meta.env.PROD ||\n//   import.meta.env.MODE === 'production';\n\n/**\n * Log levels\n */\nconst LOG_LEVELS = {\n  ERROR: 0,\n  WARN: 1,\n  INFO: 2,\n  DEBUG: 3,\n};\n\n/**\n * Current log level based on environment\n */\nconst currentLogLevel = isDevelopment ? LOG_LEVELS.DEBUG : LOG_LEVELS.ERROR;\n\n/**\n * Logger class\n */\nclass Logger {\n  static error(message, ...args) {\n    if (currentLogLevel >= LOG_LEVELS.ERROR) {\n      console.error(`[ERROR] ${message}`, ...args);\n    }\n  }\n\n  static warn(message, ...args) {\n    if (currentLogLevel >= LOG_LEVELS.WARN) {\n      console.warn(`[WARN] ${message}`, ...args);\n    }\n  }\n\n  static info(message, ...args) {\n    if (currentLogLevel >= LOG_LEVELS.INFO) {\n      console.info(`[INFO] ${message}`, ...args);\n    }\n  }\n\n  static debug(message, ...args) {\n    if (currentLogLevel >= LOG_LEVELS.DEBUG) {\n      console.debug(`[DEBUG] ${message}`, ...args);\n    }\n  }\n\n  /**\n   * Log WebRTC events (only in development)\n   */\n  static webrtc(event, data = {}) {\n    if (isDevelopment) {\n      console.debug(`[WebRTC] ${event}`, data);\n    }\n  }\n\n  /**\n   * Log API calls (only in development)\n   */\n  static api(method, endpoint, data = {}) {\n    if (isDevelopment) {\n      console.debug(`[API] ${method} ${endpoint}`, data);\n    }\n  }\n\n  /**\n   * Log user actions (only in development)\n   */\n  static user(action, data = {}) {\n    if (isDevelopment) {\n      console.debug(`[USER] ${action}`, data);\n    }\n  }\n}\n\n// Export the static class directly\nexport default Logger;\n","/**\n * Application Constants\n * Centralized constants to prevent magic strings and improve maintainability\n */\n\n// Connection States\nexport const CONNECTION_STATES = {\n  DISCONNECTED: 'disconnected',\n  CONNECTING: 'connecting',\n  CONNECTED: 'connected',\n  FAILED: 'failed',\n};\n\n// User Roles\nexport const ROLES = {\n  HOST: 'host',\n  VIEWER: 'viewer',\n};\n\n// UI States\nexport const UI_STATES = {\n  HOME: 'home',\n  HOST: 'host',\n  VIEWER: 'viewer',\n};\n\n// Copy Status\nexport const COPY_STATUS = {\n  SUCCESS: 'success',\n  ERROR: 'error',\n};\n\n// Error Messages\nexport const ERROR_MESSAGES = {\n  ROOM_NOT_FOUND: 'Room not found. Please check the room ID and make sure the host has started sharing.',\n  CONNECTION_FAILED: 'Failed to connect to host. Please check the room ID and try again.',\n  SCREEN_SHARE_FAILED: 'Failed to start screen sharing. Please check your browser permissions.',\n  INVALID_ROOM_ID: 'Room ID must be exactly 24 characters and contain only letters and numbers',\n  INVALID_VIEWER_ID: 'Viewer ID can only contain letters, numbers, spaces, hyphens, and underscores',\n  CONNECTION_TIMEOUT: 'Connection timeout. Please try again.',\n};\n\n// Success Messages\nexport const SUCCESS_MESSAGES = {\n  ROOM_CREATED: 'Room created successfully',\n  CONNECTION_ESTABLISHED: 'Connected to host',\n  SCREEN_SHARING_STARTED: 'Screen sharing started',\n};\n\n// UI Text\nexport const UI_TEXT = {\n  START_SHARING: 'Start Sharing',\n  STOP_SHARING: 'Stop Sharing',\n  CONNECT_TO_HOST: 'Connect to Host',\n  DISCONNECT: 'Disconnect',\n  RECONNECT: 'Reconnect',\n  COPY: 'Copy',\n  COPIED: 'Copied!',\n  FAILED: 'Failed!',\n  CONNECTING: 'Connecting...',\n  CONNECTED: 'Connected',\n  DISCONNECTED: 'Disconnected',\n  HOST_ONLINE: 'Host Online',\n  HOST_OFFLINE: 'Host Offline',\n  CONNECTING_TO_HOST: 'Connecting to Host...',\n  UNKNOWN: 'Unknown',\n};\n\n// Status Colors (Tailwind classes)\nexport const STATUS_COLORS = {\n  SUCCESS: 'text-green-600',\n  WARNING: 'text-yellow-600',\n  ERROR: 'text-red-600',\n  INFO: 'text-blue-600',\n  DEFAULT: 'text-gray-600',\n};\n\n// Background Colors (Tailwind classes)\nexport const BACKGROUND_COLORS = {\n  SUCCESS: 'bg-green-600',\n  WARNING: 'bg-yellow-600',\n  ERROR: 'bg-red-600',\n  INFO: 'bg-blue-600',\n  DEFAULT: 'bg-gray-600',\n};\n\n// Validation Rules\nexport const VALIDATION_RULES = {\n  ROOM_ID_LENGTH: 24,\n  VIEWER_ID_MIN_LENGTH: 3,\n  VIEWER_ID_MAX_LENGTH: 50,\n  MESSAGE_MAX_LENGTH: 500,\n  SENDER_MAX_LENGTH: 50,\n};\n\n// Polling Intervals (milliseconds)\nexport const POLLING_INTERVALS = {\n  DEFAULT: 1000,\n  REDUCED: 5000,\n  CANDIDATE_TIMEOUT: 120000, // 2 minutes\n  OFFER_TIMEOUT: 60000, // 1 minute\n  ANSWER_TIMEOUT: 60000, // 1 minute\n};\n\n// UI Delays (milliseconds)\nexport const UI_DELAYS = {\n  COPY_FEEDBACK: 2000,\n  RECONNECT_DELAY: 1000,\n};\n\n// Redis Keys\nexport const REDIS_KEYS = {\n  ROOM_META: (roomId) => `room:${roomId}:meta`,\n  ROOM_OFFER: (roomId) => `room:${roomId}:offer`,\n  ROOM_ANSWER: (roomId) => `room:${roomId}:answer`,\n  ROOM_CANDIDATES: (roomId, role, viewerId) =>\n    role === ROLES.VIEWER && viewerId\n      ? `room:${roomId}:${role}:${viewerId}:candidates`\n      : `room:${roomId}:${role}:candidates`,\n  ROOM_CHAT: (roomId) => `room:${roomId}:chat`,\n  ROOM_SENDER: (roomId, senderId) => `room:${roomId}:sender:${senderId}`,\n};\n\n// API Endpoints\nexport const API_ENDPOINTS = {\n  CONFIG: '/api/config',\n  CREATE_ROOM: '/api/create-room',\n  OFFER: '/api/offer',\n  ANSWER: '/api/answer',\n  CANDIDATE: '/api/candidate',\n  CHAT: '/api/chat',\n  DIAGNOSTICS: '/api/diagnostics',\n  VIEWERS: '/api/viewers',\n  REGISTER_SENDER: '/api/register-sender',\n};\n","/**\n * Polling Utilities\n * Provides exponential backoff and timeout functionality for polling operations\n */\n\nimport { POLLING_INTERVALS } from '../constants';\n\n/**\n * Create a polling function with exponential backoff\n * @param {Function} pollFn - The function to call for polling\n * @param {Object} options - Polling options\n * @param {number} options.initialInterval - Initial polling interval in ms\n * @param {number} options.maxInterval - Maximum polling interval in ms\n * @param {number} options.backoffFactor - Factor to multiply interval by on backoff\n * @param {number} options.maxPolls - Maximum number of polls before timeout\n * @param {number} options.backoffAfter - Number of polls before starting backoff\n * @returns {Function} - Polling function that returns a promise\n */\nexport function createExponentialBackoffPolling(pollFn, options = {}) {\n  const {\n    initialInterval = POLLING_INTERVALS.DEFAULT,\n    maxInterval = 30000, // 30 seconds max\n    backoffFactor = 1.5,\n    maxPolls = 60,\n    backoffAfter = 10,\n  } = options;\n\n  return async () => {\n    let pollCount = 0;\n    let currentInterval = initialInterval;\n\n    const poll = async () => {\n      pollCount++;\n\n      // Check timeout\n      if (pollCount > maxPolls) {\n        throw new Error('Polling timeout reached');\n      }\n\n      // Execute the polling function\n      const result = await pollFn();\n\n      // If we get a result, return it\n      if (result) {\n        return result;\n      }\n\n      // If no result and we've hit the backoff threshold, increase interval\n      if (pollCount > backoffAfter) {\n        currentInterval = Math.min(currentInterval * backoffFactor, maxInterval);\n      }\n\n      // Schedule next poll\n      return new Promise((resolve, reject) => {\n        const timeoutId = setTimeout(async () => {\n          try {\n            const nextResult = await poll();\n            resolve(nextResult);\n          } catch (error) {\n            reject(error);\n          }\n        }, currentInterval);\n\n        // Store timeout ID for potential cleanup\n        poll.timeoutId = timeoutId;\n      });\n    };\n\n    return poll();\n  };\n}\n\n/**\n * Create a simple polling function with timeout\n * @param {Function} pollFn - The function to call for polling\n * @param {Object} options - Polling options\n * @param {number} options.interval - Polling interval in ms\n * @param {number} options.maxPolls - Maximum number of polls before timeout\n * @returns {Function} - Polling function that returns a promise\n */\nexport function createSimplePolling(pollFn, options = {}) {\n  const { interval = POLLING_INTERVALS.DEFAULT, maxPolls = 60 } = options;\n\n  return async () => {\n    let pollCount = 0;\n\n    const poll = async () => {\n      pollCount++;\n\n      // Check timeout\n      if (pollCount > maxPolls) {\n        throw new Error('Polling timeout reached');\n      }\n\n      // Execute the polling function\n      const result = await pollFn();\n\n      // If we get a result, return it\n      if (result) {\n        return result;\n      }\n\n      // Schedule next poll\n      return new Promise((resolve, reject) => {\n        const timeoutId = setTimeout(async () => {\n          try {\n            const nextResult = await poll();\n            resolve(nextResult);\n          } catch (error) {\n            reject(error);\n          }\n        }, interval);\n\n        // Store timeout ID for potential cleanup\n        poll.timeoutId = timeoutId;\n      });\n    };\n\n    return poll();\n  };\n}\n\n/**\n * Stop a polling function by clearing its timeout\n * @param {Function} pollFn - The polling function to stop\n */\nexport function stopPolling(pollFn) {\n  if (pollFn.timeoutId) {\n    clearTimeout(pollFn.timeoutId);\n    pollFn.timeoutId = null;\n  }\n}\n","import { useState, useEffect, useRef, useCallback } from 'react';\nimport { getIceServers } from '../config/turn.js';\nimport logger from '../utils/logger';\nimport { createExponentialBackoffPolling } from '../utils/polling';\n\nexport function useWebRTC(roomId, role, config, _viewerId = null) {\n  // State\n  const [connectionState, setConnectionState] = useState('disconnected');\n  const [remoteStream, setRemoteStream] = useState(null);\n  const [localStream, setLocalStream] = useState(null);\n  const [error, setError] = useState(null);\n  const [iceServers, setIceServers] = useState([]);\n  const [senderSecret, setSenderSecret] = useState(null);\n\n  // Multi-viewer support: Map of viewerId to peer connections\n  const [peerConnections, _setPeerConnections] = useState(new Map());\n  const [viewerCount, _setViewerCount] = useState(0);\n\n  // Granular error state for better user feedback\n  const [errorState, setErrorState] = useState({\n    type: null, // 'permission', 'network', 'webrtc', 'timeout', 'unknown'\n    code: null, // Specific error code\n    message: null, // User-friendly message\n    details: null, // Technical details for debugging\n  });\n\n  // Refs\n  const peerConnectionRef = useRef(null);\n  const dataChannelRef = useRef(null);\n  const offerIntervalRef = useRef(null);\n  const answerIntervalRef = useRef(null);\n  const candidateIntervalRef = useRef(null);\n  const isMountedRef = useRef(true);\n  const localStreamRef = useRef(null);\n\n  // Initialize ICE servers\n  useEffect(() => {\n    // Use TURN server configuration by default for better connectivity\n    const servers = getIceServers(config?.useTurn !== false); // Default to true unless explicitly disabled\n    setIceServers(servers);\n  }, [config]);\n\n  // Helper function to set granular error state\n  const setGranularError = useCallback((type, code, message, details = null) => {\n    setErrorState({ type, code, message, details });\n    setError(message);\n    logger.error(`WebRTC Error [${type}]: ${message}`, { code, details });\n  }, []);\n\n  // Register sender and get secret for authentication\n  const registerSender = useCallback(async () => {\n    if (!roomId || !role) return null;\n\n    try {\n      const senderId = role === 'viewer' && _viewerId ? _viewerId : role;\n      const response = await fetch('/api/register-sender', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          ...(config?.authSecret && { 'x-auth-secret': config.authSecret }),\n        },\n        body: JSON.stringify({\n          roomId,\n          senderId,\n        }),\n      });\n\n      if (!response.ok) {\n        throw new Error(`Failed to register sender: ${response.status}`);\n      }\n\n      const data = await response.json();\n      return data.secret;\n    } catch (err) {\n      logger.error('Error registering sender:', err);\n      // Don't throw - this is optional authentication\n      return null;\n    }\n  }, [roomId, role, _viewerId, config]);\n\n  // Send ICE candidate\n  const sendICECandidate = useCallback(\n    async (candidate) => {\n      if (!roomId || !role) return;\n\n      try {\n        const response = await fetch('/api/candidate', {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            ...(config?.authSecret && { 'x-auth-secret': config.authSecret }),\n            ...(senderSecret && { 'x-sender-secret': senderSecret }),\n          },\n          body: JSON.stringify({\n            roomId,\n            role,\n            viewerId: _viewerId, // Include viewer ID for proper identification\n            candidate: candidate, // Send RTCIceCandidate directly\n          }),\n        });\n\n        if (!response.ok) {\n          throw new Error(`Failed to send ICE candidate: ${response.status}`);\n        }\n      } catch (err) {\n        logger.error('Error sending ICE candidate:', err);\n        setGranularError(\n          'network',\n          'SEND_ICE_CANDIDATE_FAILED',\n          'Failed to send ICE candidate to server. Please check your connection and try again.',\n          err.message\n        );\n        // Don't throw for ICE candidate failures - they're not critical\n        // Just log the error and continue\n      }\n    },\n    [roomId, role, config, _viewerId, setGranularError, senderSecret] // Added senderSecret to dependency array\n  );\n\n  // Create peer connection\n  const createPeerConnection = useCallback(() => {\n    // Ensure iceServers is not empty\n    const servers = iceServers.length > 0 ? iceServers : getIceServers(true);\n    const pc = new RTCPeerConnection({\n      iceServers: servers,\n    });\n\n    // Handle ICE candidates\n    pc.onicecandidate = (event) => {\n      if (event.candidate) {\n        try {\n          // Validate candidate before sending\n          if (\n            event.candidate.candidate &&\n            event.candidate.sdpMid !== undefined &&\n            event.candidate.sdpMLineIndex !== undefined\n          ) {\n            sendICECandidate(event.candidate);\n          } else {\n            logger.warn('Invalid ICE candidate received, skipping:', event.candidate);\n          }\n        } catch (err) {\n          logger.error('Error handling ICE candidate:', err);\n          // Don't crash the connection for ICE candidate errors\n        }\n      }\n    };\n\n    // Handle ICE gathering state changes\n    pc.onicegatheringstatechange = () => {\n      logger.webrtc('ICE gathering state changed', { state: pc.iceGatheringState });\n      // ICE gathering completing is normal - don't set an error\n      // Candidates are sent via onicecandidate as they're generated\n    };\n\n    // Handle connection state changes\n    pc.onconnectionstatechange = () => {\n      logger.webrtc('Connection state changed', { state: pc.connectionState });\n      setConnectionState(pc.connectionState);\n\n      // Clear error state on successful connection\n      if (pc.connectionState === 'connected') {\n        setError(null);\n        setErrorState({ type: null, code: null, message: null, details: null });\n      }\n\n      // Clear polling intervals when connected or failed\n      if (pc.connectionState === 'connected' || pc.connectionState === 'failed') {\n        if (offerIntervalRef.current) {\n          clearInterval(offerIntervalRef.current);\n          offerIntervalRef.current = null;\n        }\n        if (answerIntervalRef.current) {\n          clearInterval(answerIntervalRef.current);\n          answerIntervalRef.current = null;\n        }\n        if (candidateIntervalRef.current) {\n          clearInterval(candidateIntervalRef.current);\n          candidateIntervalRef.current = null;\n        }\n      }\n\n      // Cleanup peer connection on disconnect or failure\n      if (pc.connectionState === 'disconnected' || pc.connectionState === 'failed' || pc.connectionState === 'closed') {\n        // Use setTimeout to avoid cleanup during state change\n        setTimeout(() => {\n          if (peerConnectionRef.current === pc) {\n            try {\n              pc.close();\n              peerConnectionRef.current = null;\n            } catch (err) {\n              logger.error('Error during peer connection cleanup:', err);\n            }\n          }\n        }, 0);\n      }\n    };\n\n    // Handle ICE connection state changes\n    pc.oniceconnectionstatechange = () => {\n      logger.webrtc('ICE connection state changed', { state: pc.iceConnectionState });\n\n      // Handle ICE connection failures\n      if (pc.iceConnectionState === 'failed') {\n        setConnectionState('failed');\n        setGranularError(\n          'webrtc',\n          'ICE_CONNECTION_FAILED',\n          'Connection failed - unable to establish network connection',\n          `ICE connection state: ${pc.iceConnectionState}`\n        );\n\n        // Cleanup peer connection on ICE failure\n        setTimeout(() => {\n          if (peerConnectionRef.current === pc) {\n            try {\n              pc.close();\n              peerConnectionRef.current = null;\n            } catch (err) {\n              logger.error('Error during peer connection cleanup on ICE failure:', err);\n            }\n          }\n        }, 0);\n      }\n    };\n\n    // Handle remote stream\n    pc.ontrack = (event) => {\n      logger.webrtc('Received remote stream', { stream: event.streams[0] });\n      setRemoteStream(event.streams[0]);\n    };\n\n    // Handle data channel\n    pc.ondatachannel = (event) => {\n      const channel = event.channel;\n      dataChannelRef.current = channel;\n\n      channel.onopen = () => {\n        logger.webrtc('Data channel opened');\n      };\n\n      channel.onmessage = (event) => {\n        logger.webrtc('Received data channel message', { data: event.data });\n      };\n    };\n\n    return pc;\n  }, [iceServers, sendICECandidate, setGranularError]);\n\n  // Send offer\n  const sendOffer = useCallback(\n    async (offer) => {\n      if (!roomId) return;\n\n      try {\n        const response = await fetch('/api/offer', {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            ...(config?.authSecret && { 'x-auth-secret': config.authSecret }),\n            ...(senderSecret && { 'x-sender-secret': senderSecret }),\n          },\n          body: JSON.stringify({\n            roomId,\n            desc: offer,\n            role, // Include role for authentication\n          }),\n        });\n\n        if (!response.ok) {\n          throw new Error(`Failed to send offer: ${response.status}`);\n        }\n      } catch (err) {\n        logger.error('Error sending offer:', err);\n        setGranularError(\n          'network',\n          'SEND_OFFER_FAILED',\n          'Failed to send offer to server. Please check your connection and try again.',\n          err.message\n        );\n        throw err; // Re-throw the error so startScreenShare can handle it\n      }\n    },\n    [roomId, config, setGranularError, senderSecret, role]\n  );\n\n  // Send answer\n  const sendAnswer = useCallback(\n    async (answer) => {\n      if (!roomId) return;\n\n      try {\n        const response = await fetch('/api/answer', {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            ...(config?.authSecret && { 'x-auth-secret': config.authSecret }),\n            ...(senderSecret && { 'x-sender-secret': senderSecret }),\n          },\n          body: JSON.stringify({\n            roomId,\n            desc: answer,\n            role, // Include role for authentication\n          }),\n        });\n\n        if (!response.ok) {\n          throw new Error(`Failed to send answer: ${response.status}`);\n        }\n      } catch (err) {\n        logger.error('Error sending answer:', err);\n        setGranularError(\n          'network',\n          'SEND_ANSWER_FAILED',\n          'Failed to send answer to server. Please check your connection and try again.',\n          err.message\n        );\n        throw err; // Re-throw the error so the caller can handle it\n      }\n    },\n    [roomId, config, setGranularError, senderSecret, role]\n  );\n\n  // Start polling for ICE candidates with exponential backoff\n  const startCandidatePolling = useCallback(async () => {\n    if (candidateIntervalRef.current) {\n      clearInterval(candidateIntervalRef.current);\n    }\n\n    const pollFn = async () => {\n      try {\n        const response = await fetch(\n          `/api/candidate?roomId=${roomId}&role=${role}${_viewerId ? `&viewerId=${_viewerId}` : ''}`\n        );\n\n        if (response.ok) {\n          const data = await response.json();\n          if (data.candidates && data.candidates.length > 0) {\n            const pc = peerConnectionRef.current;\n            if (pc) {\n              // Check if remote description is set before adding candidates\n              if (!pc.remoteDescription) {\n                logger.warn('Cannot add ICE candidates yet - remote description not set. Will retry.');\n                return false; // Continue polling until remote description is set\n              }\n\n              for (const candidate of data.candidates) {\n                try {\n                  // Validate candidate before adding\n                  if (\n                    candidate &&\n                    typeof candidate === 'object' &&\n                    candidate.candidate &&\n                    candidate.sdpMid !== undefined &&\n                    candidate.sdpMLineIndex !== undefined\n                  ) {\n                    await pc.addIceCandidate(candidate);\n                    logger.webrtc('Added ICE candidate', { candidate });\n                  } else {\n                    logger.warn('Invalid ICE candidate received, skipping:', candidate);\n                  }\n                } catch (err) {\n                  logger.error('Error adding ICE candidate:', err);\n                  // Continue with other candidates\n                }\n              }\n            }\n            return true; // Success, stop polling\n          }\n        } else if (response.status === 404) {\n          // No candidates yet, continue polling\n          return false;\n        } else {\n          logger.error('Error polling for ICE candidates:', response.status);\n          return true; // Error, stop polling\n        }\n        return false;\n      } catch (err) {\n        // Handle network errors gracefully - don't crash the connection\n        logger.error('Network error polling for ICE candidates:', err);\n        return false; // Continue polling despite error\n      }\n    };\n\n    const polling = createExponentialBackoffPolling(pollFn, {\n      initialInterval: 1000,\n      maxInterval: 5000,\n      maxPolls: 30, // 30 seconds timeout for ICE candidates\n    });\n\n    try {\n      await polling();\n    } catch (err) {\n      // ICE candidate timeout is expected if no remote peer connects\n      logger.warn('ICE candidate polling timeout - no remote peer connected yet', err);\n      // Don't set error state - this is expected when starting without a viewer\n      // The connection will retry when a viewer actually connects\n    }\n  }, [roomId, role, _viewerId, setGranularError]);\n\n  // Start polling for offers (viewer)\n  const startOfferPolling = useCallback(async () => {\n    // Clear any existing interval\n    if (offerIntervalRef.current) {\n      clearInterval(offerIntervalRef.current);\n      offerIntervalRef.current = null;\n    }\n\n    // The polling function that will be repeatedly called\n    const pollFn = async () => {\n      try {\n        const response = await fetch(`/api/offer?roomId=${roomId}`);\n\n        if (response.ok) {\n          const data = await response.json();\n          if (data.desc) {\n            // SUCCESS: We got the offer\n            const pc = createPeerConnection();\n            peerConnectionRef.current = pc;\n\n            await pc.setRemoteDescription(data.desc);\n            const answer = await pc.createAnswer();\n            await pc.setLocalDescription(answer);\n            await sendAnswer(answer);\n\n            startCandidatePolling(); // Start polling for candidates now\n            return true; // Signal to the poller to stop\n          }\n        }\n        // If response is 404 or not OK, we continue polling\n        return false; // Signal to the poller to continue\n      } catch (err) {\n        logger.error('Network error while polling for offer:', err);\n        return false; // Signal to continue polling even on network errors\n      }\n    };\n\n    // Create and run the poller\n    const polling = createExponentialBackoffPolling(pollFn, {\n      maxPolls: 15, // ~60 seconds total timeout with backoff\n    });\n\n    try {\n      await polling();\n    } catch (err) {\n      // This block runs only if the polling times out completely\n      logger.error('Offer polling timed out.', err);\n      if (isMountedRef.current) {\n        setGranularError(\n          'timeout',\n          'OFFER_POLLING_TIMEOUT',\n          'Connection timeout: No offer received from host. Make sure the host has started sharing.',\n          err.message\n        );\n        setConnectionState('failed');\n      }\n    }\n  }, [roomId, sendAnswer, createPeerConnection, startCandidatePolling, setGranularError]);\n\n  // Start polling for answers (host)\n  const startAnswerPolling = useCallback(async () => {\n    // Clear any existing interval\n    if (answerIntervalRef.current) {\n      clearInterval(answerIntervalRef.current);\n      answerIntervalRef.current = null;\n    }\n\n    const pollFn = async () => {\n      try {\n        const response = await fetch(`/api/answer?roomId=${roomId}`);\n        if (response.ok) {\n          const data = await response.json();\n          if (data.desc) {\n            // SUCCESS: We got the answer\n            const pc = peerConnectionRef.current;\n            if (pc) {\n              await pc.setRemoteDescription(data.desc);\n            }\n            return true; // Stop polling\n          }\n        }\n        return false; // Continue polling\n      } catch (err) {\n        logger.error('Network error while polling for answer:', err);\n        return false; // Continue polling\n      }\n    };\n\n    const polling = createExponentialBackoffPolling(pollFn, {\n      maxPolls: 15,\n    });\n\n    try {\n      await polling();\n    } catch (err) {\n      // Answer timeout is expected if no viewer connects - don't show as error\n      logger.warn('Answer polling timed out - no viewer connected yet', err);\n      // Don't set error state or change connection state\n      // The host can continue sharing and wait for viewers\n    }\n  }, [roomId, setGranularError]);\n\n  // Fixed: Added _viewerId to dependency array\n\n  // Start screen sharing (host)\n  const startScreenShare = useCallback(async () => {\n    if (role !== 'host') {\n      throw new Error('Only hosts can start screen sharing');\n    }\n\n    try {\n      setError(null);\n      setConnectionState('connecting');\n\n      // Register sender and get secret for authentication\n      const secret = await registerSender();\n      if (secret) {\n        setSenderSecret(secret);\n      }\n\n      // Get screen share stream\n      const stream = await navigator.mediaDevices.getDisplayMedia({\n        video: true,\n        audio: true,\n      });\n\n      // Check what permissions were actually granted\n      const videoTracks = stream.getVideoTracks();\n      const audioTracks = stream.getAudioTracks();\n\n      if (videoTracks.length === 0) {\n        setGranularError(\n          'permission',\n          'VIDEO_DENIED',\n          'Video permission is required to share your screen. Please allow video access and try again.',\n          'User denied video permission in getDisplayMedia'\n        );\n        throw new Error('Video permission denied - cannot share screen without video');\n      }\n\n      if (audioTracks.length === 0) {\n        logger.warn('Audio permission denied - screen sharing will be video-only');\n        // Don't throw error for audio - video-only is acceptable\n      }\n\n      setLocalStream(stream);\n      localStreamRef.current = stream;\n\n      // Create peer connection\n      const pc = createPeerConnection();\n      peerConnectionRef.current = pc;\n\n      // Add transceivers to peer connection (modern WebRTC approach)\n      stream.getTracks().forEach((track) => {\n        pc.addTransceiver(track, {\n          streams: [stream],\n          direction: 'sendonly', // Host sends media to viewers\n        });\n      });\n\n      // Create and send offer\n      const offer = await pc.createOffer({\n        offerToReceiveAudio: true,\n        offerToReceiveVideo: true,\n      });\n\n      await pc.setLocalDescription(offer);\n      await sendOffer(offer);\n\n      // Keep connection state as 'connecting' after successful offer sending\n      // The connection state will be updated by the peer connection event handlers\n\n      // Start polling for answers (don't await - let it run in background)\n      startAnswerPolling().catch((err) => {\n        logger.error('Answer polling failed:', err);\n      });\n\n      // Start polling for ICE candidates (don't await - let it run in background)\n      startCandidatePolling().catch((err) => {\n        logger.error('ICE candidate polling failed:', err);\n      });\n\n      return stream;\n    } catch (err) {\n      logger.error('Error starting screen share:', err);\n      setConnectionState('failed');\n\n      // Cleanup any resources that were created\n      if (localStreamRef.current) {\n        localStreamRef.current.getTracks().forEach((track) => track.stop());\n        localStreamRef.current = null;\n        setLocalStream(null);\n      }\n\n      if (peerConnectionRef.current) {\n        try {\n          peerConnectionRef.current.close();\n          peerConnectionRef.current = null;\n        } catch (cleanupErr) {\n          logger.error('Error during peer connection cleanup:', cleanupErr);\n        }\n      }\n\n      // Set granular error based on error type\n      if (err.name === 'NotAllowedError' || err.message.includes('Permission denied')) {\n        setGranularError(\n          'permission',\n          'PERMISSION_DENIED',\n          'Screen sharing permission was denied. Please allow permission and try again.',\n          err.message\n        );\n      } else if (err.name === 'NotFoundError') {\n        setGranularError(\n          'permission',\n          'NO_DISPLAY_AVAILABLE',\n          'No display available for screen sharing. Please ensure you have a screen to share.',\n          err.message\n        );\n      } else if (err.name === 'AbortError') {\n        setGranularError(\n          'permission',\n          'SHARING_CANCELLED',\n          'Screen sharing was cancelled. Please try again.',\n          err.message\n        );\n      } else if (err.message.includes('createOffer')) {\n        setGranularError(\n          'webrtc',\n          'CREATE_OFFER_FAILED',\n          'Failed to create WebRTC offer. Please try again.',\n          err.message\n        );\n      } else if (err.message.includes('setLocalDescription')) {\n        setGranularError(\n          'webrtc',\n          'SET_LOCAL_DESCRIPTION_FAILED',\n          'Failed to set local description. Please try again.',\n          err.message\n        );\n      } else if (err.message.includes('Failed to send offer')) {\n        setGranularError(\n          'network',\n          'SEND_OFFER_FAILED',\n          'Failed to send offer to server. Please check your connection and try again.',\n          err.message\n        );\n      } else {\n        setGranularError('unknown', 'UNKNOWN_ERROR', 'An unexpected error occurred. Please try again.', err.message);\n      }\n\n      throw err;\n    }\n  }, [\n    role,\n    createPeerConnection,\n    sendOffer,\n    startAnswerPolling,\n    startCandidatePolling,\n    setGranularError,\n    localStreamRef,\n    registerSender,\n  ]);\n\n  // Connect to host (viewer)\n  const connectToHost = useCallback(async () => {\n    if (role !== 'viewer') {\n      throw new Error('Only viewers can connect to host');\n    }\n\n    try {\n      setError(null);\n      setConnectionState('connecting');\n\n      // Register sender and get secret for authentication\n      const secret = await registerSender();\n      if (secret) {\n        setSenderSecret(secret);\n      }\n\n      // Don't create peer connection yet - wait for offer from host\n      // Start polling for offers (ICE candidate polling will start when peer connection is created)\n      startOfferPolling();\n    } catch (err) {\n      logger.error('Error connecting to host:', err);\n      setConnectionState('failed');\n\n      // Cleanup any resources that were created\n      if (peerConnectionRef.current) {\n        try {\n          peerConnectionRef.current.close();\n          peerConnectionRef.current = null;\n        } catch (cleanupErr) {\n          logger.error('Error during peer connection cleanup:', cleanupErr);\n        }\n      }\n\n      // Set granular error based on error type\n      if (err.message.includes('Network error') || err.message.includes('fetch')) {\n        setGranularError(\n          'network',\n          'NETWORK_ERROR',\n          'Network connection failed. Please check your connection and try again.',\n          err.message\n        );\n      } else if (err.message.includes('Room not found') || err.message.includes('404')) {\n        setGranularError(\n          'network',\n          'ROOM_NOT_FOUND',\n          'Room not found. Please check the room ID and try again.',\n          err.message\n        );\n      } else {\n        setGranularError('unknown', 'UNKNOWN_ERROR', 'An unexpected error occurred. Please try again.', err.message);\n      }\n\n      throw err;\n    }\n  }, [role, startOfferPolling, setGranularError, registerSender]);\n\n  // Stop screen sharing\n  const stopScreenShare = useCallback(async () => {\n    try {\n      // Stop local stream\n      if (localStream) {\n        localStream.getTracks().forEach((track) => track.stop());\n        setLocalStream(null);\n        localStreamRef.current = null;\n      }\n\n      // Stop remote stream tracks if they exist\n      if (remoteStream) {\n        remoteStream.getTracks().forEach((track) => track.stop());\n        setRemoteStream(null);\n      }\n\n      // Close peer connection\n      if (peerConnectionRef.current) {\n        try {\n          peerConnectionRef.current.close();\n          peerConnectionRef.current = null;\n        } catch (err) {\n          logger.error('Error closing peer connection:', err);\n        }\n      }\n\n      // Clear intervals\n      if (offerIntervalRef.current) {\n        clearInterval(offerIntervalRef.current);\n        offerIntervalRef.current = null;\n      }\n\n      if (answerIntervalRef.current) {\n        clearInterval(answerIntervalRef.current);\n        answerIntervalRef.current = null;\n      }\n\n      if (candidateIntervalRef.current) {\n        clearInterval(candidateIntervalRef.current);\n        candidateIntervalRef.current = null;\n      }\n\n      setConnectionState('disconnected');\n      setRemoteStream(null);\n      setError(null);\n      setErrorState({ type: null, code: null, message: null, details: null });\n    } catch (err) {\n      logger.error('Error stopping screen share:', err);\n      setError(`Failed to stop screen sharing: ${err.message}`);\n    }\n  }, [localStream, remoteStream]);\n\n  // Disconnect\n  const disconnect = useCallback(async () => {\n    await stopScreenShare();\n  }, [stopScreenShare]);\n\n  // Start polling for offers (viewer)\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      isMountedRef.current = false; // Mark component as unmounted\n\n      if (offerIntervalRef.current) {\n        clearInterval(offerIntervalRef.current);\n        offerIntervalRef.current = null;\n      }\n      if (answerIntervalRef.current) {\n        clearInterval(answerIntervalRef.current);\n        answerIntervalRef.current = null;\n      }\n      if (candidateIntervalRef.current) {\n        clearInterval(candidateIntervalRef.current);\n        candidateIntervalRef.current = null;\n      }\n      if (peerConnectionRef.current) {\n        try {\n          peerConnectionRef.current.close();\n          peerConnectionRef.current = null;\n        } catch (err) {\n          logger.error('Error during peer connection cleanup on unmount:', err);\n        }\n      }\n\n      // Stop local stream tracks on unmount\n      const stream = localStreamRef.current;\n      if (stream) {\n        stream.getTracks().forEach((track) => track.stop());\n        localStreamRef.current = null;\n      }\n\n      // Stop remote stream tracks on unmount\n      if (remoteStream) {\n        remoteStream.getTracks().forEach((track) => track.stop());\n      }\n\n      // Clear error states on unmount\n      setError(null);\n      setErrorState({ type: null, code: null, message: null, details: null });\n      setConnectionState('disconnected');\n    };\n  }, [remoteStream]); // Include remoteStream in dependency array\n\n  return {\n    // State\n    connectionState,\n    remoteStream,\n    localStream,\n    error,\n    errorState, // Granular error state for better UI feedback\n    peerConnections, // Multi-viewer support\n    viewerCount, // Number of connected viewers\n\n    // Actions\n    startScreenShare,\n    stopScreenShare,\n    connectToHost,\n    disconnect,\n  };\n}\n"],"names":["VideoPlayer","forwardRef","className","props","ref","videoRef","useRef","internalRef","useImperativeHandle","useEffect","video","handleLoadedMetadata","handleLoadedData","handleCanPlay","handlePlay","handlePause","handleEnded","handleError","e","handleWaiting","handleStalled","jsx","DEFAULT_STUN_SERVERS","TURN_SERVERS","define_process_env_default","error","getIceServers","includeTurn","iceServers","isDevelopment","LOG_LEVELS","currentLogLevel","Logger","message","args","event","data","method","endpoint","action","CONNECTION_STATES","ERROR_MESSAGES","UI_TEXT","STATUS_COLORS","POLLING_INTERVALS","API_ENDPOINTS","createExponentialBackoffPolling","pollFn","options","initialInterval","maxInterval","backoffFactor","maxPolls","backoffAfter","pollCount","currentInterval","poll","result","resolve","reject","timeoutId","nextResult","useWebRTC","roomId","role","config","_viewerId","connectionState","setConnectionState","useState","remoteStream","setRemoteStream","localStream","setLocalStream","setError","setIceServers","senderSecret","setSenderSecret","peerConnections","_setPeerConnections","viewerCount","_setViewerCount","errorState","setErrorState","peerConnectionRef","dataChannelRef","offerIntervalRef","answerIntervalRef","candidateIntervalRef","isMountedRef","localStreamRef","servers","setGranularError","useCallback","type","code","details","logger","registerSender","senderId","response","err","sendICECandidate","candidate","createPeerConnection","pc","channel","sendOffer","offer","sendAnswer","answer","startCandidatePolling","polling","startOfferPolling","startAnswerPolling","startScreenShare","secret","stream","videoTracks","audioTracks","track","cleanupErr","connectToHost","stopScreenShare","disconnect"],"mappings":"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"}