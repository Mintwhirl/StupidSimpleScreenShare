import{r as o,j as te}from"./main-BcE9vIwY.js";const re=o.forwardRef(({className:i,...r},c)=>{const p=o.useRef(null),I=c||p;return o.useImperativeHandle(c,()=>p.current,[]),o.useEffect(()=>{const s=I.current;if(!s)return;const g=()=>{console.log("Video metadata loaded:",{duration:s.duration,videoWidth:s.videoWidth,videoHeight:s.videoHeight})},R=()=>{console.log("Video data loaded")},y=()=>{console.log("Video can start playing")},N=()=>{console.log("Video started playing")},T=()=>{console.log("Video paused")},w=()=>{console.log("Video ended")},v=A=>{console.error("Video error:",A)},D=()=>{console.log("Video waiting for data")},E=()=>{console.log("Video stalled")};return s.addEventListener("loadedmetadata",g),s.addEventListener("loadeddata",R),s.addEventListener("canplay",y),s.addEventListener("play",N),s.addEventListener("pause",T),s.addEventListener("ended",w),s.addEventListener("error",v),s.addEventListener("waiting",D),s.addEventListener("stalled",E),()=>{s.removeEventListener("loadedmetadata",g),s.removeEventListener("loadeddata",R),s.removeEventListener("canplay",y),s.removeEventListener("play",N),s.removeEventListener("pause",T),s.removeEventListener("ended",w),s.removeEventListener("error",v),s.removeEventListener("waiting",D),s.removeEventListener("stalled",E)}},[I]),te.jsx("video",{ref:I,className:i,"aria-label":"Screen sharing video stream",...r})});re.displayName="VideoPlayer";var J={};const ae=[{urls:"stun:stun.l.google.com:19302"},{urls:"stun:stun1.l.google.com:19302"},{urls:"stun:stun2.l.google.com:19302"},{urls:"stun:stun3.l.google.com:19302"},{urls:"stun:stun4.l.google.com:19302"}],K=[{urls:"turn:openrelay.metered.ca:80",username:"openrelayproject",credential:"openrelayproject"},{urls:"turn:openrelay.metered.ca:443",username:"openrelayproject",credential:"openrelayproject"},{urls:"turn:openrelay.metered.ca:443?transport=tcp",username:"openrelayproject",credential:"openrelayproject"},...J.TURN_SERVERS?(()=>{try{return JSON.parse(J.TURN_SERVERS)}catch(i){return console.error("Invalid TURN_SERVERS JSON:",i),[]}})():[]];function q(i=!1){const r=[...ae];return i&&K.length>0&&r.push(...K),r}const V=window.location.hostname==="localhost"||window.location.hostname.includes("localhost"),L={ERROR:0,WARN:1,INFO:2,DEBUG:3},x=V?L.DEBUG:L.ERROR;class a{static error(r,...c){x>=L.ERROR&&console.error(`[ERROR] ${r}`,...c)}static warn(r,...c){x>=L.WARN&&console.warn(`[WARN] ${r}`,...c)}static info(r,...c){x>=L.INFO&&console.info(`[INFO] ${r}`,...c)}static debug(r,...c){x>=L.DEBUG&&console.debug(`[DEBUG] ${r}`,...c)}static webrtc(r,c={}){V&&console.debug(`[WebRTC] ${r}`,c)}static api(r,c,p={}){V&&console.debug(`[API] ${r} ${c}`,p)}static user(r,c={}){V&&console.debug(`[USER] ${r}`,c)}}const le={DISCONNECTED:"disconnected",CONNECTING:"connecting",CONNECTED:"connected"},de={CONNECTION_FAILED:"Failed to connect to host. Please check the room ID and try again."},ue={CONNECT_TO_HOST:"Connect to Host",DISCONNECT:"Disconnect",RECONNECT:"Reconnect",CONNECTING:"Connecting...",CONNECTED:"Connected",DISCONNECTED:"Disconnected",HOST_ONLINE:"Host Online",HOST_OFFLINE:"Host Offline",CONNECTING_TO_HOST:"Connecting to Host...",UNKNOWN:"Unknown"},fe={SUCCESS:"text-green-600",WARNING:"text-yellow-600",ERROR:"text-red-600",DEFAULT:"text-gray-600"},oe={DEFAULT:1e3},Ee={CONFIG:"/api/config",CREATE_ROOM:"/api/create-room",OFFER:"/api/offer",ANSWER:"/api/answer",CANDIDATE:"/api/candidate",CHAT:"/api/chat",DIAGNOSTICS:"/api/diagnostics",VIEWERS:"/api/viewers",REGISTER_SENDER:"/api/register-sender"};function $(i,r={}){const{initialInterval:c=oe.DEFAULT,maxInterval:p=3e4,backoffFactor:I=1.5,maxPolls:s=60,backoffAfter:g=10}=r;return async()=>{let R=0,y=c;const N=async()=>{if(R++,R>s)throw new Error("Polling timeout reached");const T=await i();return T||(R>g&&(y=Math.min(y*I,p)),new Promise((w,v)=>{const D=setTimeout(async()=>{try{const E=await N();w(E)}catch(E){v(E)}},y);N.timeoutId=D}))};return N()}}function pe(i,r,c,p=null){const[I,s]=o.useState("disconnected"),[g,R]=o.useState(null),[y,N]=o.useState(null),[T,w]=o.useState(null),[v,D]=o.useState([]),[E,A]=o.useState(null),[X,se]=o.useState(new Map),[Y,ce]=o.useState(0),[z,F]=o.useState({type:null,code:null,message:null,details:null}),d=o.useRef(null),Q=o.useRef(null),S=o.useRef(null),m=o.useRef(null),C=o.useRef(null),W=o.useRef(!0),O=o.useRef(null);o.useEffect(()=>{const n=q(c?.useTurn!==!1);D(n)},[c]);const l=o.useCallback((n,e,t,u=null)=>{F({type:n,code:e,message:t,details:u}),w(t),a.error(`WebRTC Error [${n}]: ${t}`,{code:e,details:u})},[]),_=o.useCallback(async()=>{if(!i||!r)return null;try{const n=r==="viewer"&&p?p:r,e=await fetch("/api/register-sender",{method:"POST",headers:{"Content-Type":"application/json",...c?.authSecret&&{"x-auth-secret":c.authSecret}},body:JSON.stringify({roomId:i,senderId:n})});if(!e.ok)throw new Error(`Failed to register sender: ${e.status}`);return(await e.json()).secret}catch(n){return a.error("Error registering sender:",n),null}},[i,r,p,c]),j=o.useCallback(async n=>{if(!(!i||!r))try{const e=await fetch("/api/candidate",{method:"POST",headers:{"Content-Type":"application/json",...c?.authSecret&&{"x-auth-secret":c.authSecret},...E&&{"x-sender-secret":E}},body:JSON.stringify({roomId:i,role:r,viewerId:p,candidate:n})});if(!e.ok)throw new Error(`Failed to send ICE candidate: ${e.status}`)}catch(e){a.error("Error sending ICE candidate:",e),l("network","SEND_ICE_CANDIDATE_FAILED","Failed to send ICE candidate to server. Please check your connection and try again.",e.message)}},[i,r,c,p,l,E]),b=o.useCallback(()=>{const n=v.length>0?v:q(!0),e=new RTCPeerConnection({iceServers:n});return e.onicecandidate=t=>{if(t.candidate)try{t.candidate.candidate&&t.candidate.sdpMid!==void 0&&t.candidate.sdpMLineIndex!==void 0?j(t.candidate):a.warn("Invalid ICE candidate received, skipping:",t.candidate)}catch(u){a.error("Error handling ICE candidate:",u)}},e.onicegatheringstatechange=()=>{a.webrtc("ICE gathering state changed",{state:e.iceGatheringState})},e.onconnectionstatechange=()=>{a.webrtc("Connection state changed",{state:e.connectionState}),s(e.connectionState),e.connectionState==="connected"&&(w(null),F({type:null,code:null,message:null,details:null})),(e.connectionState==="connected"||e.connectionState==="failed")&&(S.current&&(clearInterval(S.current),S.current=null),m.current&&(clearInterval(m.current),m.current=null),C.current&&(clearInterval(C.current),C.current=null)),(e.connectionState==="disconnected"||e.connectionState==="failed"||e.connectionState==="closed")&&setTimeout(()=>{if(d.current===e)try{e.close(),d.current=null}catch(t){a.error("Error during peer connection cleanup:",t)}},0)},e.oniceconnectionstatechange=()=>{a.webrtc("ICE connection state changed",{state:e.iceConnectionState}),e.iceConnectionState==="failed"&&(s("failed"),l("webrtc","ICE_CONNECTION_FAILED","Connection failed - unable to establish network connection",`ICE connection state: ${e.iceConnectionState}`),setTimeout(()=>{if(d.current===e)try{e.close(),d.current=null}catch(t){a.error("Error during peer connection cleanup on ICE failure:",t)}},0))},e.ontrack=t=>{a.webrtc("Received remote stream",{stream:t.streams[0]}),R(t.streams[0])},e.ondatachannel=t=>{const u=t.channel;Q.current=u,u.onopen=()=>{a.webrtc("Data channel opened")},u.onmessage=f=>{a.webrtc("Received data channel message",{data:f.data})}},e},[v,j,l]),G=o.useCallback(async n=>{if(i)try{const e=await fetch("/api/offer",{method:"POST",headers:{"Content-Type":"application/json",...c?.authSecret&&{"x-auth-secret":c.authSecret},...E&&{"x-sender-secret":E}},body:JSON.stringify({roomId:i,desc:n,role:r})});if(!e.ok)throw new Error(`Failed to send offer: ${e.status}`)}catch(e){throw a.error("Error sending offer:",e),l("network","SEND_OFFER_FAILED","Failed to send offer to server. Please check your connection and try again.",e.message),e}},[i,c,l,E,r]),M=o.useCallback(async n=>{if(i)try{const e=await fetch("/api/answer",{method:"POST",headers:{"Content-Type":"application/json",...c?.authSecret&&{"x-auth-secret":c.authSecret},...E&&{"x-sender-secret":E}},body:JSON.stringify({roomId:i,desc:n,role:r})});if(!e.ok)throw new Error(`Failed to send answer: ${e.status}`)}catch(e){throw a.error("Error sending answer:",e),l("network","SEND_ANSWER_FAILED","Failed to send answer to server. Please check your connection and try again.",e.message),e}},[i,c,l,E,r]),P=o.useCallback(async()=>{C.current&&clearInterval(C.current);const e=$(async()=>{try{const t=await fetch(`/api/candidate?roomId=${i}&role=${r}${p?`&viewerId=${p}`:""}`);if(t.ok){const u=await t.json();if(u.candidates&&u.candidates.length>0){const f=d.current;if(f){if(!f.remoteDescription)return a.warn("Cannot add ICE candidates yet - remote description not set. Will retry."),!1;for(const h of u.candidates)try{h&&typeof h=="object"&&h.candidate&&h.sdpMid!==void 0&&h.sdpMLineIndex!==void 0?(await f.addIceCandidate(h),a.webrtc("Added ICE candidate",{candidate:h})):a.warn("Invalid ICE candidate received, skipping:",h)}catch(k){a.error("Error adding ICE candidate:",k)}}return!0}}else return t.status===404?!1:(a.error("Error polling for ICE candidates:",t.status),!0);return!1}catch(t){return a.error("Network error polling for ICE candidates:",t),!1}},{initialInterval:1e3,maxInterval:5e3,maxPolls:30});try{await e()}catch(t){a.warn("ICE candidate polling timeout - no remote peer connected yet",t)}},[i,r,p,l]),H=o.useCallback(async()=>{S.current&&(clearInterval(S.current),S.current=null);const e=$(async()=>{try{const t=await fetch(`/api/offer?roomId=${i}`);if(t.ok){const u=await t.json();if(u.desc){const f=b();d.current=f,await f.setRemoteDescription(u.desc);const h=await f.createAnswer();return await f.setLocalDescription(h),await M(h),P(),!0}}return!1}catch(t){return a.error("Network error while polling for offer:",t),!1}},{maxPolls:15});try{await e()}catch(t){a.error("Offer polling timed out.",t),W.current&&(l("timeout","OFFER_POLLING_TIMEOUT","Connection timeout: No offer received from host. Make sure the host has started sharing.",t.message),s("failed"))}},[i,M,b,P,l]),B=o.useCallback(async()=>{m.current&&(clearInterval(m.current),m.current=null);const e=$(async()=>{try{const t=await fetch(`/api/answer?roomId=${i}`);if(t.ok){const u=await t.json();if(u.desc){const f=d.current;return f&&await f.setRemoteDescription(u.desc),!0}}return!1}catch(t){return a.error("Network error while polling for answer:",t),!1}},{maxPolls:15});try{await e()}catch(t){a.warn("Answer polling timed out - no viewer connected yet",t)}},[i,l]),Z=o.useCallback(async()=>{if(r!=="host")throw new Error("Only hosts can start screen sharing");try{w(null),s("connecting");const n=await _();n&&A(n);const e=await navigator.mediaDevices.getDisplayMedia({video:!0,audio:!0}),t=e.getVideoTracks(),u=e.getAudioTracks();if(t.length===0)throw l("permission","VIDEO_DENIED","Video permission is required to share your screen. Please allow video access and try again.","User denied video permission in getDisplayMedia"),new Error("Video permission denied - cannot share screen without video");u.length===0&&a.warn("Audio permission denied - screen sharing will be video-only"),N(e),O.current=e;const f=b();d.current=f,e.getTracks().forEach(k=>{f.addTransceiver(k,{streams:[e],direction:"sendonly"})});const h=await f.createOffer({offerToReceiveAudio:!0,offerToReceiveVideo:!0});return await f.setLocalDescription(h),await G(h),B().catch(k=>{a.error("Answer polling failed:",k)}),P().catch(k=>{a.error("ICE candidate polling failed:",k)}),e}catch(n){if(a.error("Error starting screen share:",n),s("failed"),O.current&&(O.current.getTracks().forEach(e=>e.stop()),O.current=null,N(null)),d.current)try{d.current.close(),d.current=null}catch(e){a.error("Error during peer connection cleanup:",e)}throw n.name==="NotAllowedError"||n.message.includes("Permission denied")?l("permission","PERMISSION_DENIED","Screen sharing permission was denied. Please allow permission and try again.",n.message):n.name==="NotFoundError"?l("permission","NO_DISPLAY_AVAILABLE","No display available for screen sharing. Please ensure you have a screen to share.",n.message):n.name==="AbortError"?l("permission","SHARING_CANCELLED","Screen sharing was cancelled. Please try again.",n.message):n.message.includes("createOffer")?l("webrtc","CREATE_OFFER_FAILED","Failed to create WebRTC offer. Please try again.",n.message):n.message.includes("setLocalDescription")?l("webrtc","SET_LOCAL_DESCRIPTION_FAILED","Failed to set local description. Please try again.",n.message):n.message.includes("Failed to send offer")?l("network","SEND_OFFER_FAILED","Failed to send offer to server. Please check your connection and try again.",n.message):l("unknown","UNKNOWN_ERROR","An unexpected error occurred. Please try again.",n.message),n}},[r,b,G,B,P,l,O,_]),ee=o.useCallback(async()=>{if(r!=="viewer")throw new Error("Only viewers can connect to host");try{w(null),s("connecting");const n=await _();n&&A(n),H()}catch(n){if(a.error("Error connecting to host:",n),s("failed"),d.current)try{d.current.close(),d.current=null}catch(e){a.error("Error during peer connection cleanup:",e)}throw n.message.includes("Network error")||n.message.includes("fetch")?l("network","NETWORK_ERROR","Network connection failed. Please check your connection and try again.",n.message):n.message.includes("Room not found")||n.message.includes("404")?l("network","ROOM_NOT_FOUND","Room not found. Please check the room ID and try again.",n.message):l("unknown","UNKNOWN_ERROR","An unexpected error occurred. Please try again.",n.message),n}},[r,H,l,_]),U=o.useCallback(async()=>{try{if(y&&(y.getTracks().forEach(n=>n.stop()),N(null),O.current=null),g&&(g.getTracks().forEach(n=>n.stop()),R(null)),d.current)try{d.current.close(),d.current=null}catch(n){a.error("Error closing peer connection:",n)}S.current&&(clearInterval(S.current),S.current=null),m.current&&(clearInterval(m.current),m.current=null),C.current&&(clearInterval(C.current),C.current=null),s("disconnected"),R(null),w(null),F({type:null,code:null,message:null,details:null})}catch(n){a.error("Error stopping screen share:",n),w(`Failed to stop screen sharing: ${n.message}`)}},[y,g]),ne=o.useCallback(async()=>{await U()},[U]);return o.useEffect(()=>()=>{if(W.current=!1,S.current&&(clearInterval(S.current),S.current=null),m.current&&(clearInterval(m.current),m.current=null),C.current&&(clearInterval(C.current),C.current=null),d.current)try{d.current.close(),d.current=null}catch(e){a.error("Error during peer connection cleanup on unmount:",e)}const n=O.current;n&&(n.getTracks().forEach(e=>e.stop()),O.current=null),g&&g.getTracks().forEach(e=>e.stop()),w(null),F({type:null,code:null,message:null,details:null}),s("disconnected")},[g]),{connectionState:I,remoteStream:g,localStream:y,error:T,errorState:z,peerConnections:X,viewerCount:Y,startScreenShare:Z,stopScreenShare:U,connectToHost:ee,disconnect:ne}}export{Ee as A,le as C,de as E,fe as S,ue as U,re as V,pe as u};
//# sourceMappingURL=useWebRTC-XiiYbhRr.js.map
