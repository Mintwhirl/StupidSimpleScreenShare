import{r,j as _}from"./main-C6kqQlzj.js";const U=r.forwardRef(({className:a,...l},i)=>{const T=r.useRef(null),v=i||T;return r.useEffect(()=>{const n=v.current;if(!n)return;const m=()=>{console.log("Video metadata loaded:",{duration:n.duration,videoWidth:n.videoWidth,videoHeight:n.videoHeight})},g=()=>{console.log("Video data loaded")},u=()=>{console.log("Video can start playing")},y=()=>{console.log("Video started playing")},S=()=>{console.log("Video paused")},d=()=>{console.log("Video ended")},C=k=>{console.error("Video error:",k)},L=()=>{console.log("Video waiting for data")},E=()=>{console.log("Video stalled")};return n.addEventListener("loadedmetadata",m),n.addEventListener("loadeddata",g),n.addEventListener("canplay",u),n.addEventListener("play",y),n.addEventListener("pause",S),n.addEventListener("ended",d),n.addEventListener("error",C),n.addEventListener("waiting",L),n.addEventListener("stalled",E),()=>{n.removeEventListener("loadedmetadata",m),n.removeEventListener("loadeddata",g),n.removeEventListener("canplay",u),n.removeEventListener("play",y),n.removeEventListener("pause",S),n.removeEventListener("ended",d),n.removeEventListener("error",C),n.removeEventListener("waiting",L),n.removeEventListener("stalled",E)}},[v]),_.jsx("video",{ref:v,className:a,...l})});U.displayName="VideoPlayer";const W=[{urls:"stun:stun.l.google.com:19302"},{urls:"stun:stun1.l.google.com:19302"},{urls:"stun:stun2.l.google.com:19302"},{urls:"stun:stun3.l.google.com:19302"},{urls:"stun:stun4.l.google.com:19302"}],O=[{urls:"turn:openrelay.metered.ca:80",username:"openrelayproject",credential:"openrelayproject"},{urls:"turn:openrelay.metered.ca:443",username:"openrelayproject",credential:"openrelayproject"},{urls:"turn:openrelay.metered.ca:443?transport=tcp",username:"openrelayproject",credential:"openrelayproject"}];function H(a=!1){const l=[...W];return a&&O.length>0&&l.push(...O),l}function q(a,l,i,T=null){const[v,n]=r.useState("disconnected"),[m,g]=r.useState(null),[u,y]=r.useState(null),[S,d]=r.useState(null),[C,L]=r.useState({}),[E,k]=r.useState([]),f=r.useRef(null),D=r.useRef(null),s=r.useRef(null),p=r.useRef(null);r.useEffect(()=>{const e=H(i?.useTurn!==!1);k(e)},[i]);const b=r.useCallback(async e=>{if(!(!a||!l))try{const t=await fetch("/api/candidate",{method:"POST",headers:{"Content-Type":"application/json",...i?.authSecret&&{"x-auth-secret":i.authSecret}},body:JSON.stringify({roomId:a,role:l,candidate:{candidate:e.candidate,sdpMid:e.sdpMid,sdpMLineIndex:e.sdpMLineIndex}})});if(!t.ok)throw new Error(`Failed to send ICE candidate: ${t.status}`)}catch(t){console.error("Error sending ICE candidate:",t),d(`Failed to send ICE candidate: ${t.message}`)}},[a,l,i]),R=r.useCallback(()=>{const e=new RTCPeerConnection({iceServers:E});return e.onicecandidate=t=>{t.candidate&&b(t.candidate)},e.onconnectionstatechange=()=>{console.log("Connection state changed:",e.connectionState),n(e.connectionState)},e.oniceconnectionstatechange=()=>{console.log("ICE connection state changed:",e.iceConnectionState)},e.ontrack=t=>{console.log("Received remote stream:",t.streams[0]),g(t.streams[0])},e.ondatachannel=t=>{const c=t.channel;D.current=c,c.onopen=()=>{console.log("Data channel opened")},c.onmessage=o=>{console.log("Received data channel message:",o.data)}},e},[E,b]),j=r.useCallback(async e=>{if(a)try{const t=await fetch("/api/offer",{method:"POST",headers:{"Content-Type":"application/json",...i?.authSecret&&{"x-auth-secret":i.authSecret}},body:JSON.stringify({roomId:a,desc:e})});if(!t.ok)throw new Error(`Failed to send offer: ${t.status}`)}catch(t){console.error("Error sending offer:",t),d(`Failed to send offer: ${t.message}`)}},[a,i]),V=r.useCallback(async e=>{if(a)try{const t=await fetch("/api/answer",{method:"POST",headers:{"Content-Type":"application/json",...i?.authSecret&&{"x-auth-secret":i.authSecret}},body:JSON.stringify({roomId:a,desc:e})});if(!t.ok)throw new Error(`Failed to send answer: ${t.status}`)}catch(t){console.error("Error sending answer:",t),d(`Failed to send answer: ${t.message}`)}},[a,i]),P=r.useCallback(async()=>{s.current&&clearInterval(s.current);let e=0,t=1e3;const c=async()=>{try{const o=await fetch(`/api/offer?roomId=${a}`);if(o.ok){const w=await o.json();if(w.desc){clearInterval(s.current),s.current=null;const h=f.current;if(h){await h.setRemoteDescription(w.desc);const F=await h.createAnswer();await h.setLocalDescription(F),await V(F)}}}else o.status===404?(e++,e>10&&(clearInterval(s.current),t=5e3,s.current=setInterval(c,t))):console.error("Unexpected error polling for offers:",o.status)}catch(o){console.error("Error polling for offers:",o)}};s.current=setInterval(c,t)},[a,V]),$=r.useCallback(async()=>{s.current&&clearInterval(s.current);let e=0,t=1e3;const c=async()=>{try{const o=await fetch(`/api/answer?roomId=${a}`);if(o.ok){const w=await o.json();if(w.desc){clearInterval(s.current),s.current=null;const h=f.current;h&&await h.setRemoteDescription(w.desc)}}else o.status===404?(e++,e>10&&(clearInterval(s.current),t=5e3,s.current=setInterval(c,t))):console.error("Unexpected error polling for answers:",o.status)}catch(o){console.error("Error polling for answers:",o)}};s.current=setInterval(c,t)},[a]),x=r.useCallback(async()=>{p.current&&clearInterval(p.current),p.current=setInterval(async()=>{try{const e=await fetch(`/api/candidate?roomId=${a}&role=${l}`);if(e.ok){const t=await e.json();if(t.candidates&&t.candidates.length>0){const c=f.current;if(c)for(const o of t.candidates)await c.addIceCandidate(o)}}}catch(e){console.error("Error polling for ICE candidates:",e)}},1e3)},[a,l]),A=r.useCallback(async()=>{if(l!=="host")throw new Error("Only hosts can start screen sharing");try{d(null),n("connecting");const e=await navigator.mediaDevices.getDisplayMedia({video:!0,audio:!0});y(e);const t=R();f.current=t,e.getTracks().forEach(o=>{t.addTrack(o,e)});const c=await t.createOffer({offerToReceiveAudio:!0,offerToReceiveVideo:!0});return await t.setLocalDescription(c),await j(c),$(),e}catch(e){throw console.error("Error starting screen share:",e),d(`Failed to start screen sharing: ${e.message}`),n("disconnected"),e}},[l,R,j,$]),M=r.useCallback(async()=>{if(l!=="viewer")throw new Error("Only viewers can connect to host");try{d(null),n("connecting");const e=R();f.current=e,P(),x()}catch(e){throw console.error("Error connecting to host:",e),d(`Failed to connect to host: ${e.message}`),n("disconnected"),e}},[l,R,x,P]),I=r.useCallback(async()=>{try{u&&(u.getTracks().forEach(e=>e.stop()),y(null)),f.current&&(f.current.close(),f.current=null),s.current&&(clearInterval(s.current),s.current=null),p.current&&(clearInterval(p.current),p.current=null),n("disconnected"),g(null)}catch(e){console.error("Error stopping screen share:",e),d(`Failed to stop screen sharing: ${e.message}`)}},[u]),N=r.useCallback(async()=>{await I()},[I]);return r.useEffect(()=>()=>{s.current&&clearInterval(s.current),p.current&&clearInterval(p.current),f.current&&f.current.close(),u&&u.getTracks().forEach(e=>e.stop())},[u]),{connectionState:v,remoteStream:m,localStream:u,error:S,peerConnections:C,startScreenShare:A,stopScreenShare:I,connectToHost:M,disconnect:N}}export{U as V,q as u};
//# sourceMappingURL=useWebRTC-DLgaRGov.js.map
