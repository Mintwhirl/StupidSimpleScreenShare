import{r as n,j as J}from"./main-xztR9ljU.js";const _=n.forwardRef(({className:s,...u},d)=>{const E=n.useRef(null),m=d||E;return n.useImperativeHandle(d,()=>E.current,[]),n.useEffect(()=>{const r=m.current;if(!r)return;const R=()=>{console.log("Video metadata loaded:",{duration:r.duration,videoWidth:r.videoWidth,videoHeight:r.videoHeight})},S=()=>{console.log("Video data loaded")},h=()=>{console.log("Video can start playing")},C=()=>{console.log("Video started playing")},k=()=>{console.log("Video paused")},l=()=>{console.log("Video ended")},L=b=>{console.error("Video error:",b)},P=()=>{console.log("Video waiting for data")},I=()=>{console.log("Video stalled")};return r.addEventListener("loadedmetadata",R),r.addEventListener("loadeddata",S),r.addEventListener("canplay",h),r.addEventListener("play",C),r.addEventListener("pause",k),r.addEventListener("ended",l),r.addEventListener("error",L),r.addEventListener("waiting",P),r.addEventListener("stalled",I),()=>{r.removeEventListener("loadedmetadata",R),r.removeEventListener("loadeddata",S),r.removeEventListener("canplay",h),r.removeEventListener("play",C),r.removeEventListener("pause",k),r.removeEventListener("ended",l),r.removeEventListener("error",L),r.removeEventListener("waiting",P),r.removeEventListener("stalled",I)}},[m]),J.jsx("video",{ref:m,className:s,...u})});_.displayName="VideoPlayer";const q=[{urls:"stun:stun.l.google.com:19302"},{urls:"stun:stun1.l.google.com:19302"},{urls:"stun:stun2.l.google.com:19302"},{urls:"stun:stun3.l.google.com:19302"},{urls:"stun:stun4.l.google.com:19302"}],M=[{urls:"turn:openrelay.metered.ca:80",username:"openrelayproject",credential:"openrelayproject"},{urls:"turn:openrelay.metered.ca:443",username:"openrelayproject",credential:"openrelayproject"},{urls:"turn:openrelay.metered.ca:443?transport=tcp",username:"openrelayproject",credential:"openrelayproject"}];function z(s=!1){const u=[...q];return s&&M.length>0&&u.push(...M),u}function G(s,u,d,E=null){const[m,r]=n.useState("disconnected"),[R,S]=n.useState(null),[h,C]=n.useState(null),[k,l]=n.useState(null),[L,P]=n.useState({}),[I,b]=n.useState([]),v=n.useRef(null),A=n.useRef(null),a=n.useRef(null),o=n.useRef(null),f=n.useRef(null),w=n.useRef(!0);n.useEffect(()=>{const e=z(d?.useTurn!==!1);b(e)},[d]);const x=n.useCallback(async e=>{if(!(!s||!u))try{const t=await fetch("/api/candidate",{method:"POST",headers:{"Content-Type":"application/json",...d?.authSecret&&{"x-auth-secret":d.authSecret}},body:JSON.stringify({roomId:s,role:u,viewerId:E,candidate:{candidate:e.candidate,sdpMid:e.sdpMid,sdpMLineIndex:e.sdpMLineIndex}})});if(!t.ok)throw new Error(`Failed to send ICE candidate: ${t.status}`)}catch(t){console.error("Error sending ICE candidate:",t),l(`Failed to send ICE candidate: ${t.message}`)}},[s,u,d,E]),T=n.useCallback(()=>{const e=new RTCPeerConnection({iceServers:I});return e.onicecandidate=t=>{t.candidate&&x(t.candidate)},e.onconnectionstatechange=()=>{console.log("Connection state changed:",e.connectionState),r(e.connectionState),(e.connectionState==="connected"||e.connectionState==="failed")&&(a.current&&(clearInterval(a.current),a.current=null),o.current&&(clearInterval(o.current),o.current=null),f.current&&(clearInterval(f.current),f.current=null))},e.oniceconnectionstatechange=()=>{console.log("ICE connection state changed:",e.iceConnectionState)},e.ontrack=t=>{console.log("Received remote stream:",t.streams[0]),S(t.streams[0])},e.ondatachannel=t=>{const i=t.channel;A.current=i,i.onopen=()=>{console.log("Data channel opened")},i.onmessage=p=>{console.log("Received data channel message:",p.data)}},e},[I,x]),V=n.useCallback(async e=>{if(s)try{const t=await fetch("/api/offer",{method:"POST",headers:{"Content-Type":"application/json",...d?.authSecret&&{"x-auth-secret":d.authSecret}},body:JSON.stringify({roomId:s,desc:e})});if(!t.ok)throw new Error(`Failed to send offer: ${t.status}`)}catch(t){console.error("Error sending offer:",t),l(`Failed to send offer: ${t.message}`)}},[s,d]),F=n.useCallback(async e=>{if(s)try{const t=await fetch("/api/answer",{method:"POST",headers:{"Content-Type":"application/json",...d?.authSecret&&{"x-auth-secret":d.authSecret}},body:JSON.stringify({roomId:s,desc:e})});if(!t.ok)throw new Error(`Failed to send answer: ${t.status}`)}catch(t){console.error("Error sending answer:",t),l(`Failed to send answer: ${t.message}`)}},[s,d]),O=n.useCallback(async()=>{a.current&&clearInterval(a.current);let e=0,t=1e3;const i=60,p=async()=>{try{if(e++,e>i){clearInterval(a.current),a.current=null,w.current&&(l("Connection timeout: No offer received from host. Make sure the host has started sharing."),r("failed"));return}const c=await fetch(`/api/offer?roomId=${s}`);if(c.ok){const y=await c.json();if(y.desc){clearInterval(a.current),a.current=null;const g=T();v.current=g,await g.setRemoteDescription(y.desc);const D=await g.createAnswer();await g.setLocalDescription(D),await F(D),$()}}else c.status===404?e>10&&(clearInterval(a.current),t=5e3,a.current=setInterval(p,t)):(console.error("Unexpected error polling for offers:",c.status),clearInterval(a.current),a.current=null,w.current&&(l(`Server error: ${c.status}`),r("failed")))}catch(c){console.error("Error polling for offers:",c),clearInterval(a.current),a.current=null,w.current&&(l(`Network error: ${c.message}`),r("failed"))}};a.current=setInterval(p,t)},[s,F,T,$]),N=n.useCallback(async()=>{o.current&&clearInterval(o.current);let e=0,t=1e3;const i=60,p=async()=>{try{if(e++,e>i){clearInterval(o.current),o.current=null,w.current&&(l("Connection timeout: No answer received from viewer. Make sure the viewer has connected."),r("failed"));return}const c=await fetch(`/api/answer?roomId=${s}`);if(c.ok){const y=await c.json();if(y.desc){clearInterval(o.current),o.current=null;const g=v.current;g&&await g.setRemoteDescription(y.desc)}}else c.status===404?e>10&&(clearInterval(o.current),t=5e3,o.current=setInterval(p,t)):(console.error("Unexpected error polling for answers:",c.status),clearInterval(o.current),o.current=null,w.current&&(l(`Server error: ${c.status}`),r("failed")))}catch(c){console.error("Error polling for answers:",c),clearInterval(o.current),o.current=null,w.current&&(l(`Network error: ${c.message}`),r("failed"))}};o.current=setInterval(p,t)},[s]),$=n.useCallback(async()=>{f.current&&clearInterval(f.current);let e=0;const t=120;f.current=setInterval(async()=>{try{if(e++,e>t){clearInterval(f.current),f.current=null,console.warn("ICE candidate polling timeout - connection may be stuck");return}const i=await fetch(`/api/candidate?roomId=${s}&role=${u}${E?`&viewerId=${E}`:""}`);if(i.ok){const p=await i.json();if(p.candidates&&p.candidates.length>0){const c=v.current;if(c)for(const y of p.candidates)try{await c.addIceCandidate(y)}catch(g){console.warn("Failed to add ICE candidate:",g)}}}else i.status!==404&&console.error("Error polling for ICE candidates:",i.status)}catch(i){console.error("Error polling for ICE candidates:",i)}},1e3)},[s,u,E]),U=n.useCallback(async()=>{if(u!=="host")throw new Error("Only hosts can start screen sharing");try{l(null),r("connecting");const e=await navigator.mediaDevices.getDisplayMedia({video:!0,audio:!0});C(e);const t=T();v.current=t,e.getTracks().forEach(p=>{t.addTrack(p,e)});const i=await t.createOffer({offerToReceiveAudio:!0,offerToReceiveVideo:!0});return await t.setLocalDescription(i),await V(i),N(),$(),e}catch(e){throw console.error("Error starting screen share:",e),l(`Failed to start screen sharing: ${e.message}`),r("disconnected"),e}},[u,T,V,N,$]),H=n.useCallback(async()=>{if(u!=="viewer")throw new Error("Only viewers can connect to host");try{l(null),r("connecting"),O()}catch(e){throw console.error("Error connecting to host:",e),l(`Failed to connect to host: ${e.message}`),r("disconnected"),e}},[u,O]),j=n.useCallback(async()=>{try{h&&(h.getTracks().forEach(e=>e.stop()),C(null)),v.current&&(v.current.close(),v.current=null),a.current&&(clearInterval(a.current),a.current=null),o.current&&(clearInterval(o.current),o.current=null),f.current&&(clearInterval(f.current),f.current=null),r("disconnected"),S(null)}catch(e){console.error("Error stopping screen share:",e),l(`Failed to stop screen sharing: ${e.message}`)}},[h]),W=n.useCallback(async()=>{await j()},[j]);return n.useEffect(()=>()=>{w.current=!1,a.current&&clearInterval(a.current),o.current&&clearInterval(o.current),f.current&&clearInterval(f.current),v.current&&v.current.close(),h&&h.getTracks().forEach(e=>e.stop())},[h]),{connectionState:m,remoteStream:R,localStream:h,error:k,peerConnections:L,startScreenShare:U,stopScreenShare:j,connectToHost:H,disconnect:W}}export{_ as V,G as u};
//# sourceMappingURL=useWebRTC-DGpR8upg.js.map
