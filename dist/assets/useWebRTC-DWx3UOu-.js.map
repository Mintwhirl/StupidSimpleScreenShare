{"version":3,"file":"useWebRTC-DWx3UOu-.js","sources":["../../src/components/VideoPlayer.jsx","../../src/config/turn.js","../../src/utils/logger.js","../../src/constants/index.js","../../src/utils/polling.js","../../src/hooks/useWebRTC.js"],"sourcesContent":["import { forwardRef, useEffect, useRef, useImperativeHandle } from 'react';\n\nconst VideoPlayer = forwardRef(({ className, ...props }, ref) => {\n  const videoRef = useRef(null);\n  const internalRef = ref || videoRef;\n\n  // Use useImperativeHandle to properly handle ref forwarding\n  useImperativeHandle(ref, () => videoRef.current, []);\n\n  // Handle video element events\n  useEffect(() => {\n    const video = internalRef.current;\n    if (!video) return;\n\n    const handleLoadedMetadata = () => {\n      console.log('Video metadata loaded:', {\n        duration: video.duration,\n        videoWidth: video.videoWidth,\n        videoHeight: video.videoHeight,\n      });\n    };\n\n    const handleLoadedData = () => {\n      console.log('Video data loaded');\n    };\n\n    const handleCanPlay = () => {\n      console.log('Video can start playing');\n    };\n\n    const handlePlay = () => {\n      console.log('Video started playing');\n    };\n\n    const handlePause = () => {\n      console.log('Video paused');\n    };\n\n    const handleEnded = () => {\n      console.log('Video ended');\n    };\n\n    const handleError = (e) => {\n      console.error('Video error:', e);\n    };\n\n    const handleWaiting = () => {\n      console.log('Video waiting for data');\n    };\n\n    const handleStalled = () => {\n      console.log('Video stalled');\n    };\n\n    // Add event listeners\n    video.addEventListener('loadedmetadata', handleLoadedMetadata);\n    video.addEventListener('loadeddata', handleLoadedData);\n    video.addEventListener('canplay', handleCanPlay);\n    video.addEventListener('play', handlePlay);\n    video.addEventListener('pause', handlePause);\n    video.addEventListener('ended', handleEnded);\n    video.addEventListener('error', handleError);\n    video.addEventListener('waiting', handleWaiting);\n    video.addEventListener('stalled', handleStalled);\n\n    // Cleanup\n    return () => {\n      video.removeEventListener('loadedmetadata', handleLoadedMetadata);\n      video.removeEventListener('loadeddata', handleLoadedData);\n      video.removeEventListener('canplay', handleCanPlay);\n      video.removeEventListener('play', handlePlay);\n      video.removeEventListener('pause', handlePause);\n      video.removeEventListener('ended', handleEnded);\n      video.removeEventListener('error', handleError);\n      video.removeEventListener('waiting', handleWaiting);\n      video.removeEventListener('stalled', handleStalled);\n    };\n  }, [internalRef]);\n\n  return <video ref={internalRef} className={className} aria-label='Screen sharing video stream' {...props} />;\n});\n\nVideoPlayer.displayName = 'VideoPlayer';\n\nexport default VideoPlayer;\n","/**\n * TURN Server Configuration\n * Provides STUN and TURN servers for WebRTC connections\n */\n\n// Default STUN servers (free, no authentication required)\nconst DEFAULT_STUN_SERVERS = [\n  { urls: 'stun:stun.l.google.com:19302' },\n  { urls: 'stun:stun1.l.google.com:19302' },\n  { urls: 'stun:stun2.l.google.com:19302' },\n  { urls: 'stun:stun3.l.google.com:19302' },\n  { urls: 'stun:stun4.l.google.com:19302' },\n];\n\n// TURN servers (require authentication and may have costs)\nconst TURN_SERVERS = [\n  // Free TURN server for testing (may have limitations)\n  {\n    urls: 'turn:openrelay.metered.ca:80',\n    username: 'openrelayproject',\n    credential: 'openrelayproject',\n  },\n  {\n    urls: 'turn:openrelay.metered.ca:443',\n    username: 'openrelayproject',\n    credential: 'openrelayproject',\n  },\n  {\n    urls: 'turn:openrelay.metered.ca:443?transport=tcp',\n    username: 'openrelayproject',\n    credential: 'openrelayproject',\n  },\n  // Production TURN servers (if configured)\n  ...(process.env.TURN_SERVERS ? JSON.parse(process.env.TURN_SERVERS) : []),\n];\n\n/**\n * Get ICE servers configuration for WebRTC\n * @param {boolean} includeTurn - Whether to include TURN servers\n * @returns {Array} Array of ICE server configurations\n */\nexport function getIceServers(includeTurn = false) {\n  const iceServers = [...DEFAULT_STUN_SERVERS];\n\n  if (includeTurn && TURN_SERVERS.length > 0) {\n    iceServers.push(...TURN_SERVERS);\n  }\n\n  return iceServers;\n}\n\n/**\n * Get STUN servers only (for basic connectivity)\n * @returns {Array} Array of STUN server configurations\n */\nexport function getStunServers() {\n  return DEFAULT_STUN_SERVERS;\n}\n\n/**\n * Check if TURN servers are configured\n * @returns {boolean} True if TURN servers are available\n */\nexport function hasTurnServers() {\n  return TURN_SERVERS.length > 0 && process.env.TURN_USERNAME && process.env.TURN_PASSWORD;\n}\n\n/**\n * Get connection quality based on ICE gathering state\n * @param {RTCPeerConnection} peerConnection - The peer connection to check\n * @returns {string} Connection quality ('excellent', 'good', 'poor', 'unknown')\n */\nexport function getConnectionQuality(peerConnection) {\n  if (!peerConnection) return 'unknown';\n\n  // This is a simplified implementation\n  // In a real app, you'd analyze the stats for connection quality\n\n  switch (peerConnection.connectionState) {\n    case 'connected':\n      return 'excellent';\n    case 'connecting':\n      return 'good';\n    case 'disconnected':\n    case 'failed':\n      return 'poor';\n    default:\n      return 'unknown';\n  }\n}\n\n/**\n * Configure WebRTC with optimal settings\n * @param {RTCPeerConnection} peerConnection - The peer connection to configure\n * @param {boolean} useTurn - Whether to use TURN servers\n */\nexport function configureWebRTC(peerConnection, useTurn = false) {\n  if (!peerConnection) return;\n\n  // Set ICE servers\n  peerConnection.setConfiguration({\n    iceServers: getIceServers(useTurn),\n    iceCandidatePoolSize: 10,\n    iceTransportPolicy: useTurn ? 'all' : 'all',\n    bundlePolicy: 'max-bundle',\n    rtcpMuxPolicy: 'require',\n  });\n\n  // Configure ICE gathering\n  peerConnection.addEventListener('icegatheringstatechange', () => {\n    console.log('ICE gathering state:', peerConnection.iceGatheringState);\n  });\n\n  peerConnection.addEventListener('iceconnectionstatechange', () => {\n    console.log('ICE connection state:', peerConnection.iceConnectionState);\n  });\n}\n\nexport default {\n  getIceServers,\n  getStunServers,\n  hasTurnServers,\n  getConnectionQuality,\n  configureWebRTC,\n};\n","/**\n * Logger Utility\n * Centralized logging with environment-aware levels\n */\n\nconst isDevelopment =\n  import.meta.env.DEV ||\n  import.meta.env.MODE === 'development' ||\n  import.meta.env.MODE === 'test' ||\n  window.location.hostname === 'localhost' ||\n  window.location.hostname.includes('localhost');\n\n// const isProduction = import.meta.env.PROD ||\n//   import.meta.env.MODE === 'production';\n\n/**\n * Log levels\n */\nconst LOG_LEVELS = {\n  ERROR: 0,\n  WARN: 1,\n  INFO: 2,\n  DEBUG: 3,\n};\n\n/**\n * Current log level based on environment\n */\nconst currentLogLevel = isDevelopment ? LOG_LEVELS.DEBUG : LOG_LEVELS.ERROR;\n\n/**\n * Logger class\n */\nclass Logger {\n  static error(message, ...args) {\n    if (currentLogLevel >= LOG_LEVELS.ERROR) {\n      console.error(`[ERROR] ${message}`, ...args);\n    }\n  }\n\n  static warn(message, ...args) {\n    if (currentLogLevel >= LOG_LEVELS.WARN) {\n      console.warn(`[WARN] ${message}`, ...args);\n    }\n  }\n\n  static info(message, ...args) {\n    if (currentLogLevel >= LOG_LEVELS.INFO) {\n      console.info(`[INFO] ${message}`, ...args);\n    }\n  }\n\n  static debug(message, ...args) {\n    if (currentLogLevel >= LOG_LEVELS.DEBUG) {\n      console.debug(`[DEBUG] ${message}`, ...args);\n    }\n  }\n\n  /**\n   * Log WebRTC events (only in development)\n   */\n  static webrtc(event, data = {}) {\n    if (isDevelopment) {\n      console.debug(`[WebRTC] ${event}`, data);\n    }\n  }\n\n  /**\n   * Log API calls (only in development)\n   */\n  static api(method, endpoint, data = {}) {\n    if (isDevelopment) {\n      console.debug(`[API] ${method} ${endpoint}`, data);\n    }\n  }\n\n  /**\n   * Log user actions (only in development)\n   */\n  static user(action, data = {}) {\n    if (isDevelopment) {\n      console.debug(`[USER] ${action}`, data);\n    }\n  }\n}\n\n// Export the static class directly\nexport default Logger;\n","/**\n * Application Constants\n * Centralized constants to prevent magic strings and improve maintainability\n */\n\n// Connection States\nexport const CONNECTION_STATES = {\n  DISCONNECTED: 'disconnected',\n  CONNECTING: 'connecting',\n  CONNECTED: 'connected',\n  FAILED: 'failed',\n};\n\n// User Roles\nexport const ROLES = {\n  HOST: 'host',\n  VIEWER: 'viewer',\n};\n\n// UI States\nexport const UI_STATES = {\n  HOME: 'home',\n  HOST: 'host',\n  VIEWER: 'viewer',\n};\n\n// Copy Status\nexport const COPY_STATUS = {\n  SUCCESS: 'success',\n  ERROR: 'error',\n};\n\n// Error Messages\nexport const ERROR_MESSAGES = {\n  ROOM_NOT_FOUND: 'Room not found. Please check the room ID and make sure the host has started sharing.',\n  CONNECTION_FAILED: 'Failed to connect to host. Please check the room ID and try again.',\n  SCREEN_SHARE_FAILED: 'Failed to start screen sharing. Please check your browser permissions.',\n  INVALID_ROOM_ID: 'Room ID must be exactly 24 characters and contain only letters and numbers',\n  INVALID_VIEWER_ID: 'Viewer ID can only contain letters, numbers, spaces, hyphens, and underscores',\n  CONNECTION_TIMEOUT: 'Connection timeout. Please try again.',\n};\n\n// Success Messages\nexport const SUCCESS_MESSAGES = {\n  ROOM_CREATED: 'Room created successfully',\n  CONNECTION_ESTABLISHED: 'Connected to host',\n  SCREEN_SHARING_STARTED: 'Screen sharing started',\n};\n\n// UI Text\nexport const UI_TEXT = {\n  START_SHARING: 'Start Sharing',\n  STOP_SHARING: 'Stop Sharing',\n  CONNECT_TO_HOST: 'Connect to Host',\n  DISCONNECT: 'Disconnect',\n  RECONNECT: 'Reconnect',\n  COPY: 'Copy',\n  COPIED: 'Copied!',\n  FAILED: 'Failed!',\n  CONNECTING: 'Connecting...',\n  CONNECTED: 'Connected',\n  DISCONNECTED: 'Disconnected',\n  HOST_ONLINE: 'Host Online',\n  HOST_OFFLINE: 'Host Offline',\n  CONNECTING_TO_HOST: 'Connecting to Host...',\n  UNKNOWN: 'Unknown',\n};\n\n// Status Colors (Tailwind classes)\nexport const STATUS_COLORS = {\n  SUCCESS: 'text-green-600',\n  WARNING: 'text-yellow-600',\n  ERROR: 'text-red-600',\n  INFO: 'text-blue-600',\n  DEFAULT: 'text-gray-600',\n};\n\n// Background Colors (Tailwind classes)\nexport const BACKGROUND_COLORS = {\n  SUCCESS: 'bg-green-600',\n  WARNING: 'bg-yellow-600',\n  ERROR: 'bg-red-600',\n  INFO: 'bg-blue-600',\n  DEFAULT: 'bg-gray-600',\n};\n\n// Validation Rules\nexport const VALIDATION_RULES = {\n  ROOM_ID_LENGTH: 24,\n  VIEWER_ID_MIN_LENGTH: 3,\n  VIEWER_ID_MAX_LENGTH: 50,\n  MESSAGE_MAX_LENGTH: 500,\n  SENDER_MAX_LENGTH: 50,\n};\n\n// Polling Intervals (milliseconds)\nexport const POLLING_INTERVALS = {\n  DEFAULT: 1000,\n  REDUCED: 5000,\n  CANDIDATE_TIMEOUT: 120000, // 2 minutes\n  OFFER_TIMEOUT: 60000, // 1 minute\n  ANSWER_TIMEOUT: 60000, // 1 minute\n};\n\n// UI Delays (milliseconds)\nexport const UI_DELAYS = {\n  COPY_FEEDBACK: 2000,\n  RECONNECT_DELAY: 1000,\n};\n\n// Redis Keys\nexport const REDIS_KEYS = {\n  ROOM_META: (roomId) => `room:${roomId}:meta`,\n  ROOM_OFFER: (roomId) => `room:${roomId}:offer`,\n  ROOM_ANSWER: (roomId) => `room:${roomId}:answer`,\n  ROOM_CANDIDATES: (roomId, role, viewerId) =>\n    role === ROLES.VIEWER && viewerId\n      ? `room:${roomId}:${role}:${viewerId}:candidates`\n      : `room:${roomId}:${role}:candidates`,\n  ROOM_CHAT: (roomId) => `room:${roomId}:chat`,\n  ROOM_SENDER: (roomId, senderId) => `room:${roomId}:sender:${senderId}`,\n};\n\n// API Endpoints\nexport const API_ENDPOINTS = {\n  CONFIG: '/api/config',\n  CREATE_ROOM: '/api/create-room',\n  OFFER: '/api/offer',\n  ANSWER: '/api/answer',\n  CANDIDATE: '/api/candidate',\n  CHAT: '/api/chat',\n  DIAGNOSTICS: '/api/diagnostics',\n  VIEWERS: '/api/viewers',\n  REGISTER_SENDER: '/api/register-sender',\n};\n","/**\r\n * Polling Utilities\r\n * Provides exponential backoff and timeout functionality for polling operations\r\n */\r\n\r\nimport { POLLING_INTERVALS } from '../constants';\r\n\r\n/**\r\n * Create a polling function with exponential backoff\r\n * @param {Function} pollFn - The function to call for polling\r\n * @param {Object} options - Polling options\r\n * @param {number} options.initialInterval - Initial polling interval in ms\r\n * @param {number} options.maxInterval - Maximum polling interval in ms\r\n * @param {number} options.backoffFactor - Factor to multiply interval by on backoff\r\n * @param {number} options.maxPolls - Maximum number of polls before timeout\r\n * @param {number} options.backoffAfter - Number of polls before starting backoff\r\n * @returns {Function} - Polling function that returns a promise\r\n */\r\nexport function createExponentialBackoffPolling(pollFn, options = {}) {\r\n  const {\r\n    initialInterval = POLLING_INTERVALS.DEFAULT,\r\n    maxInterval = 30000, // 30 seconds max\r\n    backoffFactor = 1.5,\r\n    maxPolls = 60,\r\n    backoffAfter = 10,\r\n  } = options;\r\n\r\n  return async () => {\r\n    let pollCount = 0;\r\n    let currentInterval = initialInterval;\r\n    let pollInterval = initialInterval;\r\n\r\n    const poll = async () => {\r\n      try {\r\n        pollCount++;\r\n        \r\n        // Check timeout\r\n        if (pollCount > maxPolls) {\r\n          throw new Error('Polling timeout reached');\r\n        }\r\n\r\n        // Execute the polling function\r\n        const result = await pollFn();\r\n        \r\n        // If we get a result, return it\r\n        if (result) {\r\n          return result;\r\n        }\r\n\r\n        // If no result and we've hit the backoff threshold, increase interval\r\n        if (pollCount > backoffAfter) {\r\n          currentInterval = Math.min(currentInterval * backoffFactor, maxInterval);\r\n        }\r\n\r\n        // Schedule next poll\r\n        return new Promise((resolve, reject) => {\r\n          const timeoutId = setTimeout(async () => {\r\n            try {\r\n              const nextResult = await poll();\r\n              resolve(nextResult);\r\n            } catch (error) {\r\n              reject(error);\r\n            }\r\n          }, currentInterval);\r\n\r\n          // Store timeout ID for potential cleanup\r\n          poll.timeoutId = timeoutId;\r\n        });\r\n\r\n      } catch (error) {\r\n        throw error;\r\n      }\r\n    };\r\n\r\n    return poll();\r\n  };\r\n}\r\n\r\n/**\r\n * Create a simple polling function with timeout\r\n * @param {Function} pollFn - The function to call for polling\r\n * @param {Object} options - Polling options\r\n * @param {number} options.interval - Polling interval in ms\r\n * @param {number} options.maxPolls - Maximum number of polls before timeout\r\n * @returns {Function} - Polling function that returns a promise\r\n */\r\nexport function createSimplePolling(pollFn, options = {}) {\r\n  const {\r\n    interval = POLLING_INTERVALS.DEFAULT,\r\n    maxPolls = 60,\r\n  } = options;\r\n\r\n  return async () => {\r\n    let pollCount = 0;\r\n\r\n    const poll = async () => {\r\n      try {\r\n        pollCount++;\r\n        \r\n        // Check timeout\r\n        if (pollCount > maxPolls) {\r\n          throw new Error('Polling timeout reached');\r\n        }\r\n\r\n        // Execute the polling function\r\n        const result = await pollFn();\r\n        \r\n        // If we get a result, return it\r\n        if (result) {\r\n          return result;\r\n        }\r\n\r\n        // Schedule next poll\r\n        return new Promise((resolve, reject) => {\r\n          const timeoutId = setTimeout(async () => {\r\n            try {\r\n              const nextResult = await poll();\r\n              resolve(nextResult);\r\n            } catch (error) {\r\n              reject(error);\r\n            }\r\n          }, interval);\r\n\r\n          // Store timeout ID for potential cleanup\r\n          poll.timeoutId = timeoutId;\r\n        });\r\n\r\n      } catch (error) {\r\n        throw error;\r\n      }\r\n    };\r\n\r\n    return poll();\r\n  };\r\n}\r\n\r\n/**\r\n * Stop a polling function by clearing its timeout\r\n * @param {Function} pollFn - The polling function to stop\r\n */\r\nexport function stopPolling(pollFn) {\r\n  if (pollFn.timeoutId) {\r\n    clearTimeout(pollFn.timeoutId);\r\n    pollFn.timeoutId = null;\r\n  }\r\n}\r\n","import { useState, useEffect, useRef, useCallback } from 'react';\nimport { getIceServers } from '../config/turn.js';\nimport logger from '../utils/logger';\nimport { createExponentialBackoffPolling, stopPolling } from '../utils/polling';\n\nexport function useWebRTC(roomId, role, config, _viewerId = null) {\n  // State\n  const [connectionState, setConnectionState] = useState('disconnected');\n  const [remoteStream, setRemoteStream] = useState(null);\n  const [localStream, setLocalStream] = useState(null);\n  const [error, setError] = useState(null);\n  const [_peerConnections, _setPeerConnections] = useState({});\n  const [iceServers, setIceServers] = useState([]);\n\n  // Refs\n  const peerConnectionRef = useRef(null);\n  const dataChannelRef = useRef(null);\n  const offerIntervalRef = useRef(null);\n  const answerIntervalRef = useRef(null);\n  const candidateIntervalRef = useRef(null);\n  const isMountedRef = useRef(true);\n\n  // Initialize ICE servers\n  useEffect(() => {\n    // Use TURN server configuration by default for better connectivity\n    const servers = getIceServers(config?.useTurn !== false); // Default to true unless explicitly disabled\n    setIceServers(servers);\n  }, [config]);\n\n  // Send ICE candidate\n  const sendICECandidate = useCallback(\n    async (candidate) => {\n      if (!roomId || !role) return;\n\n      try {\n        const response = await fetch('/api/candidate', {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            ...(config?.authSecret && { 'x-auth-secret': config.authSecret }),\n          },\n          body: JSON.stringify({\n            roomId,\n            role,\n            viewerId: _viewerId, // Include viewer ID for proper identification\n            candidate: candidate, // Send RTCIceCandidate directly\n          }),\n        });\n\n        if (!response.ok) {\n          throw new Error(`Failed to send ICE candidate: ${response.status}`);\n        }\n      } catch (err) {\n        logger.error('Error sending ICE candidate:', err);\n        setError(`Failed to send ICE candidate: ${err.message}`);\n      }\n    },\n    [roomId, role, config, _viewerId] // Fixed: Added _viewerId to dependency array\n  );\n\n  // Create peer connection\n  const createPeerConnection = useCallback(() => {\n    const pc = new RTCPeerConnection({\n      iceServers,\n    });\n\n    // Handle ICE candidates\n    pc.onicecandidate = (event) => {\n      if (event.candidate) {\n        sendICECandidate(event.candidate);\n      }\n    };\n\n    // Handle connection state changes\n    pc.onconnectionstatechange = () => {\n      logger.webrtc('Connection state changed', { state: pc.connectionState });\n      setConnectionState(pc.connectionState);\n\n      // Clear polling intervals when connected or failed\n      if (pc.connectionState === 'connected' || pc.connectionState === 'failed') {\n        if (offerIntervalRef.current) {\n          clearInterval(offerIntervalRef.current);\n          offerIntervalRef.current = null;\n        }\n        if (answerIntervalRef.current) {\n          clearInterval(answerIntervalRef.current);\n          answerIntervalRef.current = null;\n        }\n        if (candidateIntervalRef.current) {\n          clearInterval(candidateIntervalRef.current);\n          candidateIntervalRef.current = null;\n        }\n      }\n    };\n\n    // Handle ICE connection state changes\n    pc.oniceconnectionstatechange = () => {\n      logger.webrtc('ICE connection state changed', { state: pc.iceConnectionState });\n    };\n\n    // Handle remote stream\n    pc.ontrack = (event) => {\n      logger.webrtc('Received remote stream', { stream: event.streams[0] });\n      setRemoteStream(event.streams[0]);\n    };\n\n    // Handle data channel\n    pc.ondatachannel = (event) => {\n      const channel = event.channel;\n      dataChannelRef.current = channel;\n\n      channel.onopen = () => {\n        logger.webrtc('Data channel opened');\n      };\n\n      channel.onmessage = (event) => {\n        logger.webrtc('Received data channel message', { data: event.data });\n      };\n    };\n\n    return pc;\n  }, [iceServers, sendICECandidate]);\n\n  // Send offer\n  const sendOffer = useCallback(\n    async (offer) => {\n      if (!roomId) return;\n\n      try {\n        const response = await fetch('/api/offer', {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            ...(config?.authSecret && { 'x-auth-secret': config.authSecret }),\n          },\n          body: JSON.stringify({\n            roomId,\n            desc: offer,\n          }),\n        });\n\n        if (!response.ok) {\n          throw new Error(`Failed to send offer: ${response.status}`);\n        }\n      } catch (err) {\n        logger.error('Error sending offer:', err);\n        setError(`Failed to send offer: ${err.message}`);\n      }\n    },\n    [roomId, config]\n  );\n\n  // Send answer\n  const sendAnswer = useCallback(\n    async (answer) => {\n      if (!roomId) return;\n\n      try {\n        const response = await fetch('/api/answer', {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            ...(config?.authSecret && { 'x-auth-secret': config.authSecret }),\n          },\n          body: JSON.stringify({\n            roomId,\n            desc: answer,\n          }),\n        });\n\n        if (!response.ok) {\n          throw new Error(`Failed to send answer: ${response.status}`);\n        }\n      } catch (err) {\n        logger.error('Error sending answer:', err);\n        setError(`Failed to send answer: ${err.message}`);\n      }\n    },\n    [roomId, config]\n  );\n\n  // Start polling for offers (viewer)\n  const startOfferPolling = useCallback(async () => {\n    if (offerIntervalRef.current) {\n      clearInterval(offerIntervalRef.current);\n    }\n\n    let pollCount = 0;\n    let pollInterval = 1000; // Start with 1 second\n    const maxPolls = 60; // 60 seconds timeout\n\n    const pollForOffer = async () => {\n      try {\n        pollCount++;\n\n        // Timeout after maxPolls attempts\n        if (pollCount > maxPolls) {\n          clearInterval(offerIntervalRef.current);\n          offerIntervalRef.current = null;\n          if (isMountedRef.current) {\n            setError('Connection timeout: No offer received from host. Make sure the host has started sharing.');\n            setConnectionState('failed');\n          }\n          return;\n        }\n\n        const response = await fetch(`/api/offer?roomId=${roomId}`);\n\n        if (response.ok) {\n          const data = await response.json();\n          if (data.desc) {\n            // Clear interval once we get an offer\n            clearInterval(offerIntervalRef.current);\n            offerIntervalRef.current = null;\n\n            // Create peer connection when we receive an offer\n            const pc = createPeerConnection();\n            peerConnectionRef.current = pc;\n\n            // Handle the offer\n            await pc.setRemoteDescription(data.desc);\n\n            // Create and send answer\n            const answer = await pc.createAnswer();\n            await pc.setLocalDescription(answer);\n            await sendAnswer(answer);\n\n            // Start ICE candidate polling now that we have a peer connection\n            startCandidatePolling();\n          }\n        } else if (response.status === 404) {\n          // Expected 404 - no offer yet, but reduce polling frequency after initial attempts\n          if (pollCount > 10) {\n            // After 10 seconds, reduce to polling every 5 seconds\n            clearInterval(offerIntervalRef.current);\n            pollInterval = 5000;\n            offerIntervalRef.current = setInterval(pollForOffer, pollInterval);\n          }\n        } else {\n          // Unexpected error\n          logger.error('Unexpected error polling for offers:', response.status);\n          clearInterval(offerIntervalRef.current);\n          offerIntervalRef.current = null;\n          if (isMountedRef.current) {\n            setError(`Server error: ${response.status}`);\n            setConnectionState('failed');\n          }\n        }\n      } catch (err) {\n        logger.error('Error polling for offers:', err);\n        clearInterval(offerIntervalRef.current);\n        offerIntervalRef.current = null;\n        if (isMountedRef.current) {\n          setError(`Network error: ${err.message}`);\n          setConnectionState('failed');\n        }\n      }\n    };\n\n    offerIntervalRef.current = setInterval(pollForOffer, pollInterval);\n  }, [roomId, sendAnswer, createPeerConnection, startCandidatePolling]);\n\n  // Start polling for answers (host)\n  const startAnswerPolling = useCallback(async () => {\n    if (answerIntervalRef.current) {\n      clearInterval(answerIntervalRef.current);\n    }\n\n    let pollCount = 0;\n    let pollInterval = 1000; // Start with 1 second\n    const maxPolls = 60; // 60 seconds timeout\n\n    const pollForAnswer = async () => {\n      try {\n        pollCount++;\n\n        // Timeout after maxPolls attempts\n        if (pollCount > maxPolls) {\n          clearInterval(answerIntervalRef.current);\n          answerIntervalRef.current = null;\n          if (isMountedRef.current) {\n            setError('Connection timeout: No answer received from viewer. Make sure the viewer has connected.');\n            setConnectionState('failed');\n          }\n          return;\n        }\n\n        const response = await fetch(`/api/answer?roomId=${roomId}`);\n\n        if (response.ok) {\n          const data = await response.json();\n          if (data.desc) {\n            // Clear interval once we get an answer\n            clearInterval(answerIntervalRef.current);\n            answerIntervalRef.current = null;\n\n            // Handle the answer\n            const pc = peerConnectionRef.current;\n            if (pc) {\n              await pc.setRemoteDescription(data.desc);\n            }\n          }\n        } else if (response.status === 404) {\n          // Expected 404 - no answer yet, but reduce polling frequency after initial attempts\n          if (pollCount > 10) {\n            // After 10 seconds, reduce to polling every 5 seconds\n            clearInterval(answerIntervalRef.current);\n            pollInterval = 5000;\n            answerIntervalRef.current = setInterval(pollForAnswer, pollInterval);\n          }\n        } else {\n          // Unexpected error\n          logger.error('Unexpected error polling for answers:', response.status);\n          clearInterval(answerIntervalRef.current);\n          answerIntervalRef.current = null;\n          if (isMountedRef.current) {\n            setError(`Server error: ${response.status}`);\n            setConnectionState('failed');\n          }\n        }\n      } catch (err) {\n        logger.error('Error polling for answers:', err);\n        clearInterval(answerIntervalRef.current);\n        answerIntervalRef.current = null;\n        if (isMountedRef.current) {\n          setError(`Network error: ${err.message}`);\n          setConnectionState('failed');\n        }\n      }\n    };\n\n    answerIntervalRef.current = setInterval(pollForAnswer, pollInterval);\n  }, [roomId]);\n\n  // Start polling for ICE candidates with exponential backoff\n  const startCandidatePolling = useCallback(async () => {\n    if (candidateIntervalRef.current) {\n      clearInterval(candidateIntervalRef.current);\n    }\n\n    const pollFn = async () => {\n      const response = await fetch(\n        `/api/candidate?roomId=${roomId}&role=${role}${_viewerId ? `&viewerId=${_viewerId}` : ''}`\n      );\n\n      if (response.ok) {\n        const data = await response.json();\n        if (data.candidates && data.candidates.length > 0) {\n          const pc = peerConnectionRef.current;\n          if (pc) {\n            for (const candidate of data.candidates) {\n              try {\n                await pc.addIceCandidate(candidate);\n              } catch (candidateErr) {\n                logger.warn('Failed to add ICE candidate:', candidateErr);\n              }\n            }\n          }\n          return true; // Found candidates\n        }\n      } else if (response.status !== 404) {\n        // 404 is expected when no candidates, but other errors are concerning\n        logger.error('Error polling for ICE candidates:', response.status);\n        throw new Error(`HTTP ${response.status}`);\n      }\n      \n      return false; // No candidates found\n    };\n\n    const pollingFunction = createExponentialBackoffPolling(pollFn, {\n      initialInterval: 1000,\n      maxInterval: 10000, // 10 seconds max\n      backoffFactor: 1.5,\n      maxPolls: 120, // 2 minutes timeout\n      backoffAfter: 10, // Start backoff after 10 polls\n    });\n\n    try {\n      await pollingFunction();\n    } catch (error) {\n      logger.warn('ICE candidate polling timeout - connection may be stuck');\n    }\n  }, [roomId, role, _viewerId]); // Fixed: Added _viewerId to dependency array\n\n  // Start screen sharing (host)\n  const startScreenShare = useCallback(async () => {\n    if (role !== 'host') {\n      throw new Error('Only hosts can start screen sharing');\n    }\n\n    try {\n      setError(null);\n      setConnectionState('connecting');\n\n      // Get screen share stream\n      const stream = await navigator.mediaDevices.getDisplayMedia({\n        video: true,\n        audio: true,\n      });\n\n      setLocalStream(stream);\n\n      // Create peer connection\n      const pc = createPeerConnection();\n      peerConnectionRef.current = pc;\n\n      // Add stream to peer connection\n      stream.getTracks().forEach((track) => {\n        pc.addTrack(track, stream);\n      });\n\n      // Create and send offer\n      const offer = await pc.createOffer({\n        offerToReceiveAudio: true,\n        offerToReceiveVideo: true,\n      });\n\n      await pc.setLocalDescription(offer);\n      await sendOffer(offer);\n\n      // Start polling for answers\n      startAnswerPolling();\n\n      // Start polling for ICE candidates\n      startCandidatePolling();\n\n      return stream;\n    } catch (err) {\n      logger.error('Error starting screen share:', err);\n      setError(`Failed to start screen sharing: ${err.message}`);\n      setConnectionState('disconnected');\n      throw err;\n    }\n  }, [role, createPeerConnection, sendOffer, startAnswerPolling, startCandidatePolling]);\n\n  // Connect to host (viewer)\n  const connectToHost = useCallback(async () => {\n    if (role !== 'viewer') {\n      throw new Error('Only viewers can connect to host');\n    }\n\n    try {\n      setError(null);\n      setConnectionState('connecting');\n\n      // Don't create peer connection yet - wait for offer from host\n      // Start polling for offers (ICE candidate polling will start when peer connection is created)\n      startOfferPolling();\n    } catch (err) {\n      logger.error('Error connecting to host:', err);\n      setError(`Failed to connect to host: ${err.message}`);\n      setConnectionState('disconnected');\n      throw err;\n    }\n  }, [role, startOfferPolling]);\n\n  // Stop screen sharing\n  const stopScreenShare = useCallback(async () => {\n    try {\n      // Stop local stream\n      if (localStream) {\n        localStream.getTracks().forEach((track) => track.stop());\n        setLocalStream(null);\n      }\n\n      // Close peer connection\n      if (peerConnectionRef.current) {\n        peerConnectionRef.current.close();\n        peerConnectionRef.current = null;\n      }\n\n      // Clear intervals\n      if (offerIntervalRef.current) {\n        clearInterval(offerIntervalRef.current);\n        offerIntervalRef.current = null;\n      }\n\n      if (answerIntervalRef.current) {\n        clearInterval(answerIntervalRef.current);\n        answerIntervalRef.current = null;\n      }\n\n      if (candidateIntervalRef.current) {\n        clearInterval(candidateIntervalRef.current);\n        candidateIntervalRef.current = null;\n      }\n\n      setConnectionState('disconnected');\n      setRemoteStream(null);\n    } catch (err) {\n      logger.error('Error stopping screen share:', err);\n      setError(`Failed to stop screen sharing: ${err.message}`);\n    }\n  }, [localStream]);\n\n  // Disconnect\n  const disconnect = useCallback(async () => {\n    await stopScreenShare();\n  }, [stopScreenShare]);\n\n  // Start polling for offers (viewer)\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      isMountedRef.current = false; // Mark component as unmounted\n\n      if (offerIntervalRef.current) {\n        clearInterval(offerIntervalRef.current);\n      }\n      if (answerIntervalRef.current) {\n        clearInterval(answerIntervalRef.current);\n      }\n      if (candidateIntervalRef.current) {\n        clearInterval(candidateIntervalRef.current);\n      }\n      if (peerConnectionRef.current) {\n        peerConnectionRef.current.close();\n      }\n      if (localStream) {\n        localStream.getTracks().forEach((track) => track.stop());\n      }\n    };\n  }, [localStream]);\n\n  return {\n    // State\n    connectionState,\n    remoteStream,\n    localStream,\n    error,\n    peerConnections: _peerConnections,\n\n    // Actions\n    startScreenShare,\n    stopScreenShare,\n    connectToHost,\n    disconnect,\n  };\n}\n"],"names":["VideoPlayer","forwardRef","className","props","ref","videoRef","useRef","internalRef","useImperativeHandle","useEffect","video","handleLoadedMetadata","handleLoadedData","handleCanPlay","handlePlay","handlePause","handleEnded","handleError","e","handleWaiting","handleStalled","jsx","DEFAULT_STUN_SERVERS","TURN_SERVERS","define_process_env_default","getIceServers","includeTurn","iceServers","isDevelopment","LOG_LEVELS","currentLogLevel","Logger","message","args","event","data","method","endpoint","action","CONNECTION_STATES","ERROR_MESSAGES","UI_TEXT","STATUS_COLORS","POLLING_INTERVALS","API_ENDPOINTS","createExponentialBackoffPolling","pollFn","options","initialInterval","maxInterval","backoffFactor","maxPolls","backoffAfter","pollCount","currentInterval","poll","result","resolve","reject","timeoutId","nextResult","error","useWebRTC","roomId","role","config","_viewerId","connectionState","setConnectionState","useState","remoteStream","setRemoteStream","localStream","setLocalStream","setError","_peerConnections","_setPeerConnections","setIceServers","peerConnectionRef","dataChannelRef","offerIntervalRef","answerIntervalRef","candidateIntervalRef","isMountedRef","servers","sendICECandidate","useCallback","candidate","response","err","logger","createPeerConnection","pc","channel","sendOffer","offer","sendAnswer","answer","startOfferPolling","pollInterval","pollForOffer","startCandidatePolling","startAnswerPolling","pollForAnswer","pollingFunction","candidateErr","startScreenShare","stream","track","connectToHost","stopScreenShare","disconnect"],"mappings":"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"}