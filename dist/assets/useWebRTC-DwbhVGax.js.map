{"version":3,"file":"useWebRTC-DwbhVGax.js","sources":["../../src/components/VideoPlayer.jsx","../../src/config/turn.js","../../src/hooks/useWebRTC.js"],"sourcesContent":["import { forwardRef, useEffect, useRef, useImperativeHandle } from 'react';\n\nconst VideoPlayer = forwardRef(({ className, ...props }, ref) => {\n  const videoRef = useRef(null);\n  const internalRef = ref || videoRef;\n\n  // Use useImperativeHandle to properly handle ref forwarding\n  useImperativeHandle(ref, () => videoRef.current, []);\n\n  // Handle video element events\n  useEffect(() => {\n    const video = internalRef.current;\n    if (!video) return;\n\n    const handleLoadedMetadata = () => {\n      console.log('Video metadata loaded:', {\n        duration: video.duration,\n        videoWidth: video.videoWidth,\n        videoHeight: video.videoHeight,\n      });\n    };\n\n    const handleLoadedData = () => {\n      console.log('Video data loaded');\n    };\n\n    const handleCanPlay = () => {\n      console.log('Video can start playing');\n    };\n\n    const handlePlay = () => {\n      console.log('Video started playing');\n    };\n\n    const handlePause = () => {\n      console.log('Video paused');\n    };\n\n    const handleEnded = () => {\n      console.log('Video ended');\n    };\n\n    const handleError = (e) => {\n      console.error('Video error:', e);\n    };\n\n    const handleWaiting = () => {\n      console.log('Video waiting for data');\n    };\n\n    const handleStalled = () => {\n      console.log('Video stalled');\n    };\n\n    // Add event listeners\n    video.addEventListener('loadedmetadata', handleLoadedMetadata);\n    video.addEventListener('loadeddata', handleLoadedData);\n    video.addEventListener('canplay', handleCanPlay);\n    video.addEventListener('play', handlePlay);\n    video.addEventListener('pause', handlePause);\n    video.addEventListener('ended', handleEnded);\n    video.addEventListener('error', handleError);\n    video.addEventListener('waiting', handleWaiting);\n    video.addEventListener('stalled', handleStalled);\n\n    // Cleanup\n    return () => {\n      video.removeEventListener('loadedmetadata', handleLoadedMetadata);\n      video.removeEventListener('loadeddata', handleLoadedData);\n      video.removeEventListener('canplay', handleCanPlay);\n      video.removeEventListener('play', handlePlay);\n      video.removeEventListener('pause', handlePause);\n      video.removeEventListener('ended', handleEnded);\n      video.removeEventListener('error', handleError);\n      video.removeEventListener('waiting', handleWaiting);\n      video.removeEventListener('stalled', handleStalled);\n    };\n  }, [internalRef]);\n\n  return <video ref={internalRef} className={className} aria-label='Screen sharing video stream' {...props} />;\n});\n\nVideoPlayer.displayName = 'VideoPlayer';\n\nexport default VideoPlayer;\n","/**\n * TURN Server Configuration\n * Provides STUN and TURN servers for WebRTC connections\n */\n\n// Default STUN servers (free, no authentication required)\nconst DEFAULT_STUN_SERVERS = [\n  { urls: 'stun:stun.l.google.com:19302' },\n  { urls: 'stun:stun1.l.google.com:19302' },\n  { urls: 'stun:stun2.l.google.com:19302' },\n  { urls: 'stun:stun3.l.google.com:19302' },\n  { urls: 'stun:stun4.l.google.com:19302' },\n];\n\n// TURN servers (require authentication and may have costs)\nconst TURN_SERVERS = [\n  // Free TURN server for testing (may have limitations)\n  {\n    urls: 'turn:openrelay.metered.ca:80',\n    username: 'openrelayproject',\n    credential: 'openrelayproject',\n  },\n  {\n    urls: 'turn:openrelay.metered.ca:443',\n    username: 'openrelayproject',\n    credential: 'openrelayproject',\n  },\n  {\n    urls: 'turn:openrelay.metered.ca:443?transport=tcp',\n    username: 'openrelayproject',\n    credential: 'openrelayproject',\n  },\n  // Production TURN servers (if configured)\n  ...(process.env.TURN_SERVERS ? JSON.parse(process.env.TURN_SERVERS) : []),\n];\n\n/**\n * Get ICE servers configuration for WebRTC\n * @param {boolean} includeTurn - Whether to include TURN servers\n * @returns {Array} Array of ICE server configurations\n */\nexport function getIceServers(includeTurn = false) {\n  const iceServers = [...DEFAULT_STUN_SERVERS];\n\n  if (includeTurn && TURN_SERVERS.length > 0) {\n    iceServers.push(...TURN_SERVERS);\n  }\n\n  return iceServers;\n}\n\n/**\n * Get STUN servers only (for basic connectivity)\n * @returns {Array} Array of STUN server configurations\n */\nexport function getStunServers() {\n  return DEFAULT_STUN_SERVERS;\n}\n\n/**\n * Check if TURN servers are configured\n * @returns {boolean} True if TURN servers are available\n */\nexport function hasTurnServers() {\n  return TURN_SERVERS.length > 0 && process.env.TURN_USERNAME && process.env.TURN_PASSWORD;\n}\n\n/**\n * Get connection quality based on ICE gathering state\n * @param {RTCPeerConnection} peerConnection - The peer connection to check\n * @returns {string} Connection quality ('excellent', 'good', 'poor', 'unknown')\n */\nexport function getConnectionQuality(peerConnection) {\n  if (!peerConnection) return 'unknown';\n\n  // This is a simplified implementation\n  // In a real app, you'd analyze the stats for connection quality\n\n  switch (peerConnection.connectionState) {\n    case 'connected':\n      return 'excellent';\n    case 'connecting':\n      return 'good';\n    case 'disconnected':\n    case 'failed':\n      return 'poor';\n    default:\n      return 'unknown';\n  }\n}\n\n/**\n * Configure WebRTC with optimal settings\n * @param {RTCPeerConnection} peerConnection - The peer connection to configure\n * @param {boolean} useTurn - Whether to use TURN servers\n */\nexport function configureWebRTC(peerConnection, useTurn = false) {\n  if (!peerConnection) return;\n\n  // Set ICE servers\n  peerConnection.setConfiguration({\n    iceServers: getIceServers(useTurn),\n    iceCandidatePoolSize: 10,\n    iceTransportPolicy: useTurn ? 'all' : 'all',\n    bundlePolicy: 'max-bundle',\n    rtcpMuxPolicy: 'require',\n  });\n\n  // Configure ICE gathering\n  peerConnection.addEventListener('icegatheringstatechange', () => {\n    console.log('ICE gathering state:', peerConnection.iceGatheringState);\n  });\n\n  peerConnection.addEventListener('iceconnectionstatechange', () => {\n    console.log('ICE connection state:', peerConnection.iceConnectionState);\n  });\n}\n\nexport default {\n  getIceServers,\n  getStunServers,\n  hasTurnServers,\n  getConnectionQuality,\n  configureWebRTC,\n};\n","import { useState, useEffect, useRef, useCallback } from 'react';\nimport { getIceServers } from '../config/turn.js';\n\nexport function useWebRTC(roomId, role, config, _viewerId = null) {\n  // State\n  const [connectionState, setConnectionState] = useState('disconnected');\n  const [remoteStream, setRemoteStream] = useState(null);\n  const [localStream, setLocalStream] = useState(null);\n  const [error, setError] = useState(null);\n  const [_peerConnections, _setPeerConnections] = useState({});\n  const [iceServers, setIceServers] = useState([]);\n\n  // Refs\n  const peerConnectionRef = useRef(null);\n  const dataChannelRef = useRef(null);\n  const offerIntervalRef = useRef(null);\n  const answerIntervalRef = useRef(null);\n  const candidateIntervalRef = useRef(null);\n  const isMountedRef = useRef(true);\n\n  // Initialize ICE servers\n  useEffect(() => {\n    // Use TURN server configuration by default for better connectivity\n    const servers = getIceServers(config?.useTurn !== false); // Default to true unless explicitly disabled\n    setIceServers(servers);\n  }, [config]);\n\n  // Send ICE candidate\n  const sendICECandidate = useCallback(\n    async (candidate) => {\n      if (!roomId || !role) return;\n\n      try {\n        const response = await fetch('/api/candidate', {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            ...(config?.authSecret && { 'x-auth-secret': config.authSecret }),\n          },\n          body: JSON.stringify({\n            roomId,\n            role,\n            viewerId: _viewerId, // Include viewer ID for proper identification\n            candidate: {\n              candidate: candidate.candidate,\n              sdpMid: candidate.sdpMid,\n              sdpMLineIndex: candidate.sdpMLineIndex,\n            },\n          }),\n        });\n\n        if (!response.ok) {\n          throw new Error(`Failed to send ICE candidate: ${response.status}`);\n        }\n      } catch (err) {\n        console.error('Error sending ICE candidate:', err);\n        setError(`Failed to send ICE candidate: ${err.message}`);\n      }\n    },\n    [roomId, role, config, _viewerId] // Fixed: Added _viewerId to dependency array\n  );\n\n  // Create peer connection\n  const createPeerConnection = useCallback(() => {\n    const pc = new RTCPeerConnection({\n      iceServers,\n    });\n\n    // Handle ICE candidates\n    pc.onicecandidate = (event) => {\n      if (event.candidate) {\n        sendICECandidate(event.candidate);\n      }\n    };\n\n    // Handle connection state changes\n    pc.onconnectionstatechange = () => {\n      console.log('Connection state changed:', pc.connectionState);\n      setConnectionState(pc.connectionState);\n\n      // Clear polling intervals when connected or failed\n      if (pc.connectionState === 'connected' || pc.connectionState === 'failed') {\n        if (offerIntervalRef.current) {\n          clearInterval(offerIntervalRef.current);\n          offerIntervalRef.current = null;\n        }\n        if (answerIntervalRef.current) {\n          clearInterval(answerIntervalRef.current);\n          answerIntervalRef.current = null;\n        }\n        if (candidateIntervalRef.current) {\n          clearInterval(candidateIntervalRef.current);\n          candidateIntervalRef.current = null;\n        }\n      }\n    };\n\n    // Handle ICE connection state changes\n    pc.oniceconnectionstatechange = () => {\n      console.log('ICE connection state changed:', pc.iceConnectionState);\n    };\n\n    // Handle remote stream\n    pc.ontrack = (event) => {\n      console.log('Received remote stream:', event.streams[0]);\n      setRemoteStream(event.streams[0]);\n    };\n\n    // Handle data channel\n    pc.ondatachannel = (event) => {\n      const channel = event.channel;\n      dataChannelRef.current = channel;\n\n      channel.onopen = () => {\n        console.log('Data channel opened');\n      };\n\n      channel.onmessage = (event) => {\n        console.log('Received data channel message:', event.data);\n      };\n    };\n\n    return pc;\n  }, [iceServers, sendICECandidate]);\n\n  // Send offer\n  const sendOffer = useCallback(\n    async (offer) => {\n      if (!roomId) return;\n\n      try {\n        const response = await fetch('/api/offer', {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            ...(config?.authSecret && { 'x-auth-secret': config.authSecret }),\n          },\n          body: JSON.stringify({\n            roomId,\n            desc: offer,\n          }),\n        });\n\n        if (!response.ok) {\n          throw new Error(`Failed to send offer: ${response.status}`);\n        }\n      } catch (err) {\n        console.error('Error sending offer:', err);\n        setError(`Failed to send offer: ${err.message}`);\n      }\n    },\n    [roomId, config]\n  );\n\n  // Send answer\n  const sendAnswer = useCallback(\n    async (answer) => {\n      if (!roomId) return;\n\n      try {\n        const response = await fetch('/api/answer', {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            ...(config?.authSecret && { 'x-auth-secret': config.authSecret }),\n          },\n          body: JSON.stringify({\n            roomId,\n            desc: answer,\n          }),\n        });\n\n        if (!response.ok) {\n          throw new Error(`Failed to send answer: ${response.status}`);\n        }\n      } catch (err) {\n        console.error('Error sending answer:', err);\n        setError(`Failed to send answer: ${err.message}`);\n      }\n    },\n    [roomId, config]\n  );\n\n  // Start polling for offers (viewer)\n  const startOfferPolling = useCallback(async () => {\n    if (offerIntervalRef.current) {\n      clearInterval(offerIntervalRef.current);\n    }\n\n    let pollCount = 0;\n    let pollInterval = 1000; // Start with 1 second\n    const maxPolls = 60; // 60 seconds timeout\n\n    const pollForOffer = async () => {\n      try {\n        pollCount++;\n\n        // Timeout after maxPolls attempts\n        if (pollCount > maxPolls) {\n          clearInterval(offerIntervalRef.current);\n          offerIntervalRef.current = null;\n          if (isMountedRef.current) {\n            setError('Connection timeout: No offer received from host. Make sure the host has started sharing.');\n            setConnectionState('failed');\n          }\n          return;\n        }\n\n        const response = await fetch(`/api/offer?roomId=${roomId}`);\n\n        if (response.ok) {\n          const data = await response.json();\n          if (data.desc) {\n            // Clear interval once we get an offer\n            clearInterval(offerIntervalRef.current);\n            offerIntervalRef.current = null;\n\n            // Create peer connection when we receive an offer\n            const pc = createPeerConnection();\n            peerConnectionRef.current = pc;\n\n            // Handle the offer\n            await pc.setRemoteDescription(data.desc);\n\n            // Create and send answer\n            const answer = await pc.createAnswer();\n            await pc.setLocalDescription(answer);\n            await sendAnswer(answer);\n\n            // Start ICE candidate polling now that we have a peer connection\n            startCandidatePolling();\n          }\n        } else if (response.status === 404) {\n          // Expected 404 - no offer yet, but reduce polling frequency after initial attempts\n          if (pollCount > 10) {\n            // After 10 seconds, reduce to polling every 5 seconds\n            clearInterval(offerIntervalRef.current);\n            pollInterval = 5000;\n            offerIntervalRef.current = setInterval(pollForOffer, pollInterval);\n          }\n        } else {\n          // Unexpected error\n          console.error('Unexpected error polling for offers:', response.status);\n          clearInterval(offerIntervalRef.current);\n          offerIntervalRef.current = null;\n          if (isMountedRef.current) {\n            setError(`Server error: ${response.status}`);\n            setConnectionState('failed');\n          }\n        }\n      } catch (err) {\n        console.error('Error polling for offers:', err);\n        clearInterval(offerIntervalRef.current);\n        offerIntervalRef.current = null;\n        if (isMountedRef.current) {\n          setError(`Network error: ${err.message}`);\n          setConnectionState('failed');\n        }\n      }\n    };\n\n    offerIntervalRef.current = setInterval(pollForOffer, pollInterval);\n  }, [roomId, sendAnswer, createPeerConnection, startCandidatePolling]);\n\n  // Start polling for answers (host)\n  const startAnswerPolling = useCallback(async () => {\n    if (answerIntervalRef.current) {\n      clearInterval(answerIntervalRef.current);\n    }\n\n    let pollCount = 0;\n    let pollInterval = 1000; // Start with 1 second\n    const maxPolls = 60; // 60 seconds timeout\n\n    const pollForAnswer = async () => {\n      try {\n        pollCount++;\n\n        // Timeout after maxPolls attempts\n        if (pollCount > maxPolls) {\n          clearInterval(answerIntervalRef.current);\n          answerIntervalRef.current = null;\n          if (isMountedRef.current) {\n            setError('Connection timeout: No answer received from viewer. Make sure the viewer has connected.');\n            setConnectionState('failed');\n          }\n          return;\n        }\n\n        const response = await fetch(`/api/answer?roomId=${roomId}`);\n\n        if (response.ok) {\n          const data = await response.json();\n          if (data.desc) {\n            // Clear interval once we get an answer\n            clearInterval(answerIntervalRef.current);\n            answerIntervalRef.current = null;\n\n            // Handle the answer\n            const pc = peerConnectionRef.current;\n            if (pc) {\n              await pc.setRemoteDescription(data.desc);\n            }\n          }\n        } else if (response.status === 404) {\n          // Expected 404 - no answer yet, but reduce polling frequency after initial attempts\n          if (pollCount > 10) {\n            // After 10 seconds, reduce to polling every 5 seconds\n            clearInterval(answerIntervalRef.current);\n            pollInterval = 5000;\n            answerIntervalRef.current = setInterval(pollForAnswer, pollInterval);\n          }\n        } else {\n          // Unexpected error\n          console.error('Unexpected error polling for answers:', response.status);\n          clearInterval(answerIntervalRef.current);\n          answerIntervalRef.current = null;\n          if (isMountedRef.current) {\n            setError(`Server error: ${response.status}`);\n            setConnectionState('failed');\n          }\n        }\n      } catch (err) {\n        console.error('Error polling for answers:', err);\n        clearInterval(answerIntervalRef.current);\n        answerIntervalRef.current = null;\n        if (isMountedRef.current) {\n          setError(`Network error: ${err.message}`);\n          setConnectionState('failed');\n        }\n      }\n    };\n\n    answerIntervalRef.current = setInterval(pollForAnswer, pollInterval);\n  }, [roomId]);\n\n  // Start polling for ICE candidates\n  const startCandidatePolling = useCallback(async () => {\n    if (candidateIntervalRef.current) {\n      clearInterval(candidateIntervalRef.current);\n    }\n\n    let pollCount = 0;\n    const maxPolls = 120; // 2 minutes timeout for ICE candidates\n\n    candidateIntervalRef.current = setInterval(async () => {\n      try {\n        pollCount++;\n\n        // Timeout after maxPolls attempts\n        if (pollCount > maxPolls) {\n          clearInterval(candidateIntervalRef.current);\n          candidateIntervalRef.current = null;\n          console.warn('ICE candidate polling timeout - connection may be stuck');\n          return;\n        }\n\n        const response = await fetch(\n          `/api/candidate?roomId=${roomId}&role=${role}${_viewerId ? `&viewerId=${_viewerId}` : ''}`\n        );\n\n        if (response.ok) {\n          const data = await response.json();\n          if (data.candidates && data.candidates.length > 0) {\n            const pc = peerConnectionRef.current;\n            if (pc) {\n              for (const candidate of data.candidates) {\n                try {\n                  await pc.addIceCandidate(candidate);\n                } catch (candidateErr) {\n                  console.warn('Failed to add ICE candidate:', candidateErr);\n                }\n              }\n            }\n          }\n        } else if (response.status !== 404) {\n          // 404 is expected when no candidates, but other errors are concerning\n          console.error('Error polling for ICE candidates:', response.status);\n        }\n      } catch (err) {\n        console.error('Error polling for ICE candidates:', err);\n      }\n    }, 1000);\n  }, [roomId, role, _viewerId]); // Fixed: Added _viewerId to dependency array\n\n  // Start screen sharing (host)\n  const startScreenShare = useCallback(async () => {\n    if (role !== 'host') {\n      throw new Error('Only hosts can start screen sharing');\n    }\n\n    try {\n      setError(null);\n      setConnectionState('connecting');\n\n      // Get screen share stream\n      const stream = await navigator.mediaDevices.getDisplayMedia({\n        video: true,\n        audio: true,\n      });\n\n      setLocalStream(stream);\n\n      // Create peer connection\n      const pc = createPeerConnection();\n      peerConnectionRef.current = pc;\n\n      // Add stream to peer connection\n      stream.getTracks().forEach((track) => {\n        pc.addTrack(track, stream);\n      });\n\n      // Create and send offer\n      const offer = await pc.createOffer({\n        offerToReceiveAudio: true,\n        offerToReceiveVideo: true,\n      });\n\n      await pc.setLocalDescription(offer);\n      await sendOffer(offer);\n\n      // Start polling for answers\n      startAnswerPolling();\n\n      // Start polling for ICE candidates\n      startCandidatePolling();\n\n      return stream;\n    } catch (err) {\n      console.error('Error starting screen share:', err);\n      setError(`Failed to start screen sharing: ${err.message}`);\n      setConnectionState('disconnected');\n      throw err;\n    }\n  }, [role, createPeerConnection, sendOffer, startAnswerPolling, startCandidatePolling]);\n\n  // Connect to host (viewer)\n  const connectToHost = useCallback(async () => {\n    if (role !== 'viewer') {\n      throw new Error('Only viewers can connect to host');\n    }\n\n    try {\n      setError(null);\n      setConnectionState('connecting');\n\n      // Don't create peer connection yet - wait for offer from host\n      // Start polling for offers (ICE candidate polling will start when peer connection is created)\n      startOfferPolling();\n    } catch (err) {\n      console.error('Error connecting to host:', err);\n      setError(`Failed to connect to host: ${err.message}`);\n      setConnectionState('disconnected');\n      throw err;\n    }\n  }, [role, startOfferPolling]);\n\n  // Stop screen sharing\n  const stopScreenShare = useCallback(async () => {\n    try {\n      // Stop local stream\n      if (localStream) {\n        localStream.getTracks().forEach((track) => track.stop());\n        setLocalStream(null);\n      }\n\n      // Close peer connection\n      if (peerConnectionRef.current) {\n        peerConnectionRef.current.close();\n        peerConnectionRef.current = null;\n      }\n\n      // Clear intervals\n      if (offerIntervalRef.current) {\n        clearInterval(offerIntervalRef.current);\n        offerIntervalRef.current = null;\n      }\n\n      if (answerIntervalRef.current) {\n        clearInterval(answerIntervalRef.current);\n        answerIntervalRef.current = null;\n      }\n\n      if (candidateIntervalRef.current) {\n        clearInterval(candidateIntervalRef.current);\n        candidateIntervalRef.current = null;\n      }\n\n      setConnectionState('disconnected');\n      setRemoteStream(null);\n    } catch (err) {\n      console.error('Error stopping screen share:', err);\n      setError(`Failed to stop screen sharing: ${err.message}`);\n    }\n  }, [localStream]);\n\n  // Disconnect\n  const disconnect = useCallback(async () => {\n    await stopScreenShare();\n  }, [stopScreenShare]);\n\n  // Start polling for offers (viewer)\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      isMountedRef.current = false; // Mark component as unmounted\n\n      if (offerIntervalRef.current) {\n        clearInterval(offerIntervalRef.current);\n      }\n      if (answerIntervalRef.current) {\n        clearInterval(answerIntervalRef.current);\n      }\n      if (candidateIntervalRef.current) {\n        clearInterval(candidateIntervalRef.current);\n      }\n      if (peerConnectionRef.current) {\n        peerConnectionRef.current.close();\n      }\n      if (localStream) {\n        localStream.getTracks().forEach((track) => track.stop());\n      }\n    };\n  }, [localStream]);\n\n  return {\n    // State\n    connectionState,\n    remoteStream,\n    localStream,\n    error,\n    peerConnections: _peerConnections,\n\n    // Actions\n    startScreenShare,\n    stopScreenShare,\n    connectToHost,\n    disconnect,\n  };\n}\n"],"names":["VideoPlayer","forwardRef","className","props","ref","videoRef","useRef","internalRef","useImperativeHandle","useEffect","video","handleLoadedMetadata","handleLoadedData","handleCanPlay","handlePlay","handlePause","handleEnded","handleError","e","handleWaiting","handleStalled","jsx","DEFAULT_STUN_SERVERS","TURN_SERVERS","define_process_env_default","getIceServers","includeTurn","iceServers","useWebRTC","roomId","role","config","_viewerId","connectionState","setConnectionState","useState","remoteStream","setRemoteStream","localStream","setLocalStream","error","setError","_peerConnections","_setPeerConnections","setIceServers","peerConnectionRef","dataChannelRef","offerIntervalRef","answerIntervalRef","candidateIntervalRef","isMountedRef","servers","sendICECandidate","useCallback","candidate","response","err","createPeerConnection","pc","event","channel","sendOffer","offer","sendAnswer","answer","startOfferPolling","pollCount","pollInterval","maxPolls","pollForOffer","data","startCandidatePolling","startAnswerPolling","pollForAnswer","candidateErr","startScreenShare","stream","track","connectToHost","stopScreenShare","disconnect"],"mappings":"8CAEA,MAAMA,EAAcC,EAAAA,WAAW,CAAC,CAAE,UAAAC,EAAW,GAAGC,CAAA,EAASC,IAAQ,CAC/D,MAAMC,EAAWC,EAAAA,OAAO,IAAI,EACtBC,EAAcH,GAAOC,EAG3BG,OAAAA,EAAAA,oBAAoBJ,EAAK,IAAMC,EAAS,QAAS,CAAA,CAAE,EAGnDI,EAAAA,UAAU,IAAM,CACd,MAAMC,EAAQH,EAAY,QAC1B,GAAI,CAACG,EAAO,OAEZ,MAAMC,EAAuB,IAAM,CACjC,QAAQ,IAAI,yBAA0B,CACpC,SAAUD,EAAM,SAChB,WAAYA,EAAM,WAClB,YAAaA,EAAM,WAAA,CACpB,CACH,EAEME,EAAmB,IAAM,CAC7B,QAAQ,IAAI,mBAAmB,CACjC,EAEMC,EAAgB,IAAM,CAC1B,QAAQ,IAAI,yBAAyB,CACvC,EAEMC,EAAa,IAAM,CACvB,QAAQ,IAAI,uBAAuB,CACrC,EAEMC,EAAc,IAAM,CACxB,QAAQ,IAAI,cAAc,CAC5B,EAEMC,EAAc,IAAM,CACxB,QAAQ,IAAI,aAAa,CAC3B,EAEMC,EAAeC,GAAM,CACzB,QAAQ,MAAM,eAAgBA,CAAC,CACjC,EAEMC,EAAgB,IAAM,CAC1B,QAAQ,IAAI,wBAAwB,CACtC,EAEMC,EAAgB,IAAM,CAC1B,QAAQ,IAAI,eAAe,CAC7B,EAGA,OAAAV,EAAM,iBAAiB,iBAAkBC,CAAoB,EAC7DD,EAAM,iBAAiB,aAAcE,CAAgB,EACrDF,EAAM,iBAAiB,UAAWG,CAAa,EAC/CH,EAAM,iBAAiB,OAAQI,CAAU,EACzCJ,EAAM,iBAAiB,QAASK,CAAW,EAC3CL,EAAM,iBAAiB,QAASM,CAAW,EAC3CN,EAAM,iBAAiB,QAASO,CAAW,EAC3CP,EAAM,iBAAiB,UAAWS,CAAa,EAC/CT,EAAM,iBAAiB,UAAWU,CAAa,EAGxC,IAAM,CACXV,EAAM,oBAAoB,iBAAkBC,CAAoB,EAChED,EAAM,oBAAoB,aAAcE,CAAgB,EACxDF,EAAM,oBAAoB,UAAWG,CAAa,EAClDH,EAAM,oBAAoB,OAAQI,CAAU,EAC5CJ,EAAM,oBAAoB,QAASK,CAAW,EAC9CL,EAAM,oBAAoB,QAASM,CAAW,EAC9CN,EAAM,oBAAoB,QAASO,CAAW,EAC9CP,EAAM,oBAAoB,UAAWS,CAAa,EAClDT,EAAM,oBAAoB,UAAWU,CAAa,CACpD,CACF,EAAG,CAACb,CAAW,CAAC,EAETc,EAAAA,IAAC,SAAM,IAAKd,EAAa,UAAAL,EAAsB,aAAW,8BAA+B,GAAGC,EAAO,CAC5G,CAAC,EAEDH,EAAY,YAAc,uBC5E1B,MAAMsB,EAAuB,CAC3B,CAAE,KAAM,8BAAA,EACR,CAAE,KAAM,+BAAA,EACR,CAAE,KAAM,+BAAA,EACR,CAAE,KAAM,+BAAA,EACR,CAAE,KAAM,+BAAA,CACV,EAGMC,EAAe,CAEnB,CACE,KAAM,+BACN,SAAU,mBACV,WAAY,kBAAA,EAEd,CACE,KAAM,gCACN,SAAU,mBACV,WAAY,kBAAA,EAEd,CACE,KAAM,8CACN,SAAU,mBACV,WAAY,kBAAA,EAGd,GAAIC,EAAY,aAAe,KAAK,MAAMA,EAAY,YAAY,EAAI,CAAA,CACxE,EAOO,SAASC,EAAcC,EAAc,GAAO,CACjD,MAAMC,EAAa,CAAC,GAAGL,CAAoB,EAE3C,OAAII,GAAeH,EAAa,OAAS,GACvCI,EAAW,KAAK,GAAGJ,CAAY,EAG1BI,CACT,CC9CO,SAASC,EAAUC,EAAQC,EAAMC,EAAQC,EAAY,KAAM,CAEhE,KAAM,CAACC,EAAiBC,CAAkB,EAAIC,EAAAA,SAAS,cAAc,EAC/D,CAACC,EAAcC,CAAe,EAAIF,EAAAA,SAAS,IAAI,EAC/C,CAACG,EAAaC,CAAc,EAAIJ,EAAAA,SAAS,IAAI,EAC7C,CAACK,EAAOC,CAAQ,EAAIN,EAAAA,SAAS,IAAI,EACjC,CAACO,EAAkBC,CAAmB,EAAIR,EAAAA,SAAS,CAAA,CAAE,EACrD,CAACR,EAAYiB,CAAa,EAAIT,EAAAA,SAAS,CAAA,CAAE,EAGzCU,EAAoBvC,EAAAA,OAAO,IAAI,EAC/BwC,EAAiBxC,EAAAA,OAAO,IAAI,EAC5ByC,EAAmBzC,EAAAA,OAAO,IAAI,EAC9B0C,EAAoB1C,EAAAA,OAAO,IAAI,EAC/B2C,EAAuB3C,EAAAA,OAAO,IAAI,EAClC4C,EAAe5C,EAAAA,OAAO,EAAI,EAGhCG,EAAAA,UAAU,IAAM,CAEd,MAAM0C,EAAU1B,EAAcM,GAAQ,UAAY,EAAK,EACvDa,EAAcO,CAAO,CACvB,EAAG,CAACpB,CAAM,CAAC,EAGX,MAAMqB,EAAmBC,EAAAA,YACvB,MAAOC,GAAc,CACnB,GAAI,GAACzB,GAAU,CAACC,GAEhB,GAAI,CACF,MAAMyB,EAAW,MAAM,MAAM,iBAAkB,CAC7C,OAAQ,OACR,QAAS,CACP,eAAgB,mBAChB,GAAIxB,GAAQ,YAAc,CAAE,gBAAiBA,EAAO,UAAU,CAC1E,EACU,KAAM,KAAK,UAAU,CACnB,OAAAF,EACA,KAAAC,EACA,SAAUE,EACV,UAAW,CACT,UAAWsB,EAAU,UACrB,OAAQA,EAAU,OAClB,cAAeA,EAAU,aACvC,CACA,CAAW,CACX,CAAS,EAED,GAAI,CAACC,EAAS,GACZ,MAAM,IAAI,MAAM,iCAAiCA,EAAS,MAAM,EAAE,CAEtE,OAASC,EAAK,CACZ,QAAQ,MAAM,+BAAgCA,CAAG,EACjDf,EAAS,iCAAiCe,EAAI,OAAO,EAAE,CACzD,CACF,EACA,CAAC3B,EAAQC,EAAMC,EAAQC,CAAS,CACpC,EAGQyB,EAAuBJ,EAAAA,YAAY,IAAM,CAC7C,MAAMK,EAAK,IAAI,kBAAkB,CAC/B,WAAA/B,CACN,CAAK,EAGD,OAAA+B,EAAG,eAAkBC,GAAU,CACzBA,EAAM,WACRP,EAAiBO,EAAM,SAAS,CAEpC,EAGAD,EAAG,wBAA0B,IAAM,CACjC,QAAQ,IAAI,4BAA6BA,EAAG,eAAe,EAC3DxB,EAAmBwB,EAAG,eAAe,GAGjCA,EAAG,kBAAoB,aAAeA,EAAG,kBAAoB,YAC3DX,EAAiB,UACnB,cAAcA,EAAiB,OAAO,EACtCA,EAAiB,QAAU,MAEzBC,EAAkB,UACpB,cAAcA,EAAkB,OAAO,EACvCA,EAAkB,QAAU,MAE1BC,EAAqB,UACvB,cAAcA,EAAqB,OAAO,EAC1CA,EAAqB,QAAU,MAGrC,EAGAS,EAAG,2BAA6B,IAAM,CACpC,QAAQ,IAAI,gCAAiCA,EAAG,kBAAkB,CACpE,EAGAA,EAAG,QAAWC,GAAU,CACtB,QAAQ,IAAI,0BAA2BA,EAAM,QAAQ,CAAC,CAAC,EACvDtB,EAAgBsB,EAAM,QAAQ,CAAC,CAAC,CAClC,EAGAD,EAAG,cAAiBC,GAAU,CAC5B,MAAMC,EAAUD,EAAM,QACtBb,EAAe,QAAUc,EAEzBA,EAAQ,OAAS,IAAM,CACrB,QAAQ,IAAI,qBAAqB,CACnC,EAEAA,EAAQ,UAAaD,GAAU,CAC7B,QAAQ,IAAI,iCAAkCA,EAAM,IAAI,CAC1D,CACF,EAEOD,CACT,EAAG,CAAC/B,EAAYyB,CAAgB,CAAC,EAG3BS,EAAYR,EAAAA,YAChB,MAAOS,GAAU,CACf,GAAKjC,EAEL,GAAI,CACF,MAAM0B,EAAW,MAAM,MAAM,aAAc,CACzC,OAAQ,OACR,QAAS,CACP,eAAgB,mBAChB,GAAIxB,GAAQ,YAAc,CAAE,gBAAiBA,EAAO,UAAU,CAC1E,EACU,KAAM,KAAK,UAAU,CACnB,OAAAF,EACA,KAAMiC,CAClB,CAAW,CACX,CAAS,EAED,GAAI,CAACP,EAAS,GACZ,MAAM,IAAI,MAAM,yBAAyBA,EAAS,MAAM,EAAE,CAE9D,OAASC,EAAK,CACZ,QAAQ,MAAM,uBAAwBA,CAAG,EACzCf,EAAS,yBAAyBe,EAAI,OAAO,EAAE,CACjD,CACF,EACA,CAAC3B,EAAQE,CAAM,CACnB,EAGQgC,EAAaV,EAAAA,YACjB,MAAOW,GAAW,CAChB,GAAKnC,EAEL,GAAI,CACF,MAAM0B,EAAW,MAAM,MAAM,cAAe,CAC1C,OAAQ,OACR,QAAS,CACP,eAAgB,mBAChB,GAAIxB,GAAQ,YAAc,CAAE,gBAAiBA,EAAO,UAAU,CAC1E,EACU,KAAM,KAAK,UAAU,CACnB,OAAAF,EACA,KAAMmC,CAClB,CAAW,CACX,CAAS,EAED,GAAI,CAACT,EAAS,GACZ,MAAM,IAAI,MAAM,0BAA0BA,EAAS,MAAM,EAAE,CAE/D,OAASC,EAAK,CACZ,QAAQ,MAAM,wBAAyBA,CAAG,EAC1Cf,EAAS,0BAA0Be,EAAI,OAAO,EAAE,CAClD,CACF,EACA,CAAC3B,EAAQE,CAAM,CACnB,EAGQkC,EAAoBZ,EAAAA,YAAY,SAAY,CAC5CN,EAAiB,SACnB,cAAcA,EAAiB,OAAO,EAGxC,IAAImB,EAAY,EACZC,EAAe,IACnB,MAAMC,EAAW,GAEXC,EAAe,SAAY,CAC/B,GAAI,CAIF,GAHAH,IAGIA,EAAYE,EAAU,CACxB,cAAcrB,EAAiB,OAAO,EACtCA,EAAiB,QAAU,KACvBG,EAAa,UACfT,EAAS,0FAA0F,EACnGP,EAAmB,QAAQ,GAE7B,MACF,CAEA,MAAMqB,EAAW,MAAM,MAAM,qBAAqB1B,CAAM,EAAE,EAE1D,GAAI0B,EAAS,GAAI,CACf,MAAMe,EAAO,MAAMf,EAAS,KAAI,EAChC,GAAIe,EAAK,KAAM,CAEb,cAAcvB,EAAiB,OAAO,EACtCA,EAAiB,QAAU,KAG3B,MAAMW,EAAKD,EAAoB,EAC/BZ,EAAkB,QAAUa,EAG5B,MAAMA,EAAG,qBAAqBY,EAAK,IAAI,EAGvC,MAAMN,EAAS,MAAMN,EAAG,aAAY,EACpC,MAAMA,EAAG,oBAAoBM,CAAM,EACnC,MAAMD,EAAWC,CAAM,EAGvBO,EAAqB,CACvB,CACF,MAAWhB,EAAS,SAAW,IAEzBW,EAAY,KAEd,cAAcnB,EAAiB,OAAO,EACtCoB,EAAe,IACfpB,EAAiB,QAAU,YAAYsB,EAAcF,CAAY,IAInE,QAAQ,MAAM,uCAAwCZ,EAAS,MAAM,EACrE,cAAcR,EAAiB,OAAO,EACtCA,EAAiB,QAAU,KACvBG,EAAa,UACfT,EAAS,iBAAiBc,EAAS,MAAM,EAAE,EAC3CrB,EAAmB,QAAQ,GAGjC,OAASsB,EAAK,CACZ,QAAQ,MAAM,4BAA6BA,CAAG,EAC9C,cAAcT,EAAiB,OAAO,EACtCA,EAAiB,QAAU,KACvBG,EAAa,UACfT,EAAS,kBAAkBe,EAAI,OAAO,EAAE,EACxCtB,EAAmB,QAAQ,EAE/B,CACF,EAEAa,EAAiB,QAAU,YAAYsB,EAAcF,CAAY,CACnE,EAAG,CAACtC,EAAQkC,EAAYN,EAAsBc,CAAqB,CAAC,EAG9DC,EAAqBnB,EAAAA,YAAY,SAAY,CAC7CL,EAAkB,SACpB,cAAcA,EAAkB,OAAO,EAGzC,IAAIkB,EAAY,EACZC,EAAe,IACnB,MAAMC,EAAW,GAEXK,EAAgB,SAAY,CAChC,GAAI,CAIF,GAHAP,IAGIA,EAAYE,EAAU,CACxB,cAAcpB,EAAkB,OAAO,EACvCA,EAAkB,QAAU,KACxBE,EAAa,UACfT,EAAS,yFAAyF,EAClGP,EAAmB,QAAQ,GAE7B,MACF,CAEA,MAAMqB,EAAW,MAAM,MAAM,sBAAsB1B,CAAM,EAAE,EAE3D,GAAI0B,EAAS,GAAI,CACf,MAAMe,EAAO,MAAMf,EAAS,KAAI,EAChC,GAAIe,EAAK,KAAM,CAEb,cAActB,EAAkB,OAAO,EACvCA,EAAkB,QAAU,KAG5B,MAAMU,EAAKb,EAAkB,QACzBa,GACF,MAAMA,EAAG,qBAAqBY,EAAK,IAAI,CAE3C,CACF,MAAWf,EAAS,SAAW,IAEzBW,EAAY,KAEd,cAAclB,EAAkB,OAAO,EACvCmB,EAAe,IACfnB,EAAkB,QAAU,YAAYyB,EAAeN,CAAY,IAIrE,QAAQ,MAAM,wCAAyCZ,EAAS,MAAM,EACtE,cAAcP,EAAkB,OAAO,EACvCA,EAAkB,QAAU,KACxBE,EAAa,UACfT,EAAS,iBAAiBc,EAAS,MAAM,EAAE,EAC3CrB,EAAmB,QAAQ,GAGjC,OAASsB,EAAK,CACZ,QAAQ,MAAM,6BAA8BA,CAAG,EAC/C,cAAcR,EAAkB,OAAO,EACvCA,EAAkB,QAAU,KACxBE,EAAa,UACfT,EAAS,kBAAkBe,EAAI,OAAO,EAAE,EACxCtB,EAAmB,QAAQ,EAE/B,CACF,EAEAc,EAAkB,QAAU,YAAYyB,EAAeN,CAAY,CACrE,EAAG,CAACtC,CAAM,CAAC,EAGL0C,EAAwBlB,EAAAA,YAAY,SAAY,CAChDJ,EAAqB,SACvB,cAAcA,EAAqB,OAAO,EAG5C,IAAIiB,EAAY,EAChB,MAAME,EAAW,IAEjBnB,EAAqB,QAAU,YAAY,SAAY,CACrD,GAAI,CAIF,GAHAiB,IAGIA,EAAYE,EAAU,CACxB,cAAcnB,EAAqB,OAAO,EAC1CA,EAAqB,QAAU,KAC/B,QAAQ,KAAK,yDAAyD,EACtE,MACF,CAEA,MAAMM,EAAW,MAAM,MACrB,yBAAyB1B,CAAM,SAASC,CAAI,GAAGE,EAAY,aAAaA,CAAS,GAAK,EAAE,EAClG,EAEQ,GAAIuB,EAAS,GAAI,CACf,MAAMe,EAAO,MAAMf,EAAS,KAAI,EAChC,GAAIe,EAAK,YAAcA,EAAK,WAAW,OAAS,EAAG,CACjD,MAAMZ,EAAKb,EAAkB,QAC7B,GAAIa,EACF,UAAWJ,KAAagB,EAAK,WAC3B,GAAI,CACF,MAAMZ,EAAG,gBAAgBJ,CAAS,CACpC,OAASoB,EAAc,CACrB,QAAQ,KAAK,+BAAgCA,CAAY,CAC3D,CAGN,CACF,MAAWnB,EAAS,SAAW,KAE7B,QAAQ,MAAM,oCAAqCA,EAAS,MAAM,CAEtE,OAASC,EAAK,CACZ,QAAQ,MAAM,oCAAqCA,CAAG,CACxD,CACF,EAAG,GAAI,CACT,EAAG,CAAC3B,EAAQC,EAAME,CAAS,CAAC,EAGtB2C,EAAmBtB,EAAAA,YAAY,SAAY,CAC/C,GAAIvB,IAAS,OACX,MAAM,IAAI,MAAM,qCAAqC,EAGvD,GAAI,CACFW,EAAS,IAAI,EACbP,EAAmB,YAAY,EAG/B,MAAM0C,EAAS,MAAM,UAAU,aAAa,gBAAgB,CAC1D,MAAO,GACP,MAAO,EACf,CAAO,EAEDrC,EAAeqC,CAAM,EAGrB,MAAMlB,EAAKD,EAAoB,EAC/BZ,EAAkB,QAAUa,EAG5BkB,EAAO,UAAS,EAAG,QAASC,GAAU,CACpCnB,EAAG,SAASmB,EAAOD,CAAM,CAC3B,CAAC,EAGD,MAAMd,EAAQ,MAAMJ,EAAG,YAAY,CACjC,oBAAqB,GACrB,oBAAqB,EAC7B,CAAO,EAED,aAAMA,EAAG,oBAAoBI,CAAK,EAClC,MAAMD,EAAUC,CAAK,EAGrBU,EAAkB,EAGlBD,EAAqB,EAEdK,CACT,OAASpB,EAAK,CACZ,cAAQ,MAAM,+BAAgCA,CAAG,EACjDf,EAAS,mCAAmCe,EAAI,OAAO,EAAE,EACzDtB,EAAmB,cAAc,EAC3BsB,CACR,CACF,EAAG,CAAC1B,EAAM2B,EAAsBI,EAAWW,EAAoBD,CAAqB,CAAC,EAG/EO,EAAgBzB,EAAAA,YAAY,SAAY,CAC5C,GAAIvB,IAAS,SACX,MAAM,IAAI,MAAM,kCAAkC,EAGpD,GAAI,CACFW,EAAS,IAAI,EACbP,EAAmB,YAAY,EAI/B+B,EAAiB,CACnB,OAAST,EAAK,CACZ,cAAQ,MAAM,4BAA6BA,CAAG,EAC9Cf,EAAS,8BAA8Be,EAAI,OAAO,EAAE,EACpDtB,EAAmB,cAAc,EAC3BsB,CACR,CACF,EAAG,CAAC1B,EAAMmC,CAAiB,CAAC,EAGtBc,EAAkB1B,EAAAA,YAAY,SAAY,CAC9C,GAAI,CAEEf,IACFA,EAAY,UAAS,EAAG,QAASuC,GAAUA,EAAM,MAAM,EACvDtC,EAAe,IAAI,GAIjBM,EAAkB,UACpBA,EAAkB,QAAQ,MAAK,EAC/BA,EAAkB,QAAU,MAI1BE,EAAiB,UACnB,cAAcA,EAAiB,OAAO,EACtCA,EAAiB,QAAU,MAGzBC,EAAkB,UACpB,cAAcA,EAAkB,OAAO,EACvCA,EAAkB,QAAU,MAG1BC,EAAqB,UACvB,cAAcA,EAAqB,OAAO,EAC1CA,EAAqB,QAAU,MAGjCf,EAAmB,cAAc,EACjCG,EAAgB,IAAI,CACtB,OAASmB,EAAK,CACZ,QAAQ,MAAM,+BAAgCA,CAAG,EACjDf,EAAS,kCAAkCe,EAAI,OAAO,EAAE,CAC1D,CACF,EAAG,CAAClB,CAAW,CAAC,EAGV0C,EAAa3B,EAAAA,YAAY,SAAY,CACzC,MAAM0B,EAAe,CACvB,EAAG,CAACA,CAAe,CAAC,EAKpBtE,OAAAA,EAAAA,UAAU,IACD,IAAM,CACXyC,EAAa,QAAU,GAEnBH,EAAiB,SACnB,cAAcA,EAAiB,OAAO,EAEpCC,EAAkB,SACpB,cAAcA,EAAkB,OAAO,EAErCC,EAAqB,SACvB,cAAcA,EAAqB,OAAO,EAExCJ,EAAkB,SACpBA,EAAkB,QAAQ,MAAK,EAE7BP,GACFA,EAAY,UAAS,EAAG,QAASuC,GAAUA,EAAM,MAAM,CAE3D,EACC,CAACvC,CAAW,CAAC,EAET,CAEL,gBAAAL,EACA,aAAAG,EACA,YAAAE,EACA,MAAAE,EACA,gBAAiBE,EAGjB,iBAAAiC,EACA,gBAAAI,EACA,cAAAD,EACA,WAAAE,CACJ,CACA"}