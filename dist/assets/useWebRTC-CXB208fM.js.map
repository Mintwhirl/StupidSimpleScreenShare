{"version":3,"file":"useWebRTC-CXB208fM.js","sources":["../../src/components/VideoPlayer.jsx","../../src/config/turn.js","../../src/utils/logger.js","../../src/constants/index.js","../../src/utils/polling.js","../../src/hooks/useWebRTC.js"],"sourcesContent":["import { forwardRef, useEffect, useRef, useImperativeHandle } from 'react';\n\nconst VideoPlayer = forwardRef(({ className, ...props }, ref) => {\n  const videoRef = useRef(null);\n  const internalRef = ref || videoRef;\n\n  // Use useImperativeHandle to properly handle ref forwarding\n  useImperativeHandle(ref, () => videoRef.current, []);\n\n  // Handle video element events\n  useEffect(() => {\n    const video = internalRef.current;\n    if (!video) return;\n\n    const handleLoadedMetadata = () => {\n      console.log('Video metadata loaded:', {\n        duration: video.duration,\n        videoWidth: video.videoWidth,\n        videoHeight: video.videoHeight,\n      });\n    };\n\n    const handleLoadedData = () => {\n      console.log('Video data loaded');\n    };\n\n    const handleCanPlay = () => {\n      console.log('Video can start playing');\n    };\n\n    const handlePlay = () => {\n      console.log('Video started playing');\n    };\n\n    const handlePause = () => {\n      console.log('Video paused');\n    };\n\n    const handleEnded = () => {\n      console.log('Video ended');\n    };\n\n    const handleError = (e) => {\n      console.error('Video error:', e);\n    };\n\n    const handleWaiting = () => {\n      console.log('Video waiting for data');\n    };\n\n    const handleStalled = () => {\n      console.log('Video stalled');\n    };\n\n    // Add event listeners\n    video.addEventListener('loadedmetadata', handleLoadedMetadata);\n    video.addEventListener('loadeddata', handleLoadedData);\n    video.addEventListener('canplay', handleCanPlay);\n    video.addEventListener('play', handlePlay);\n    video.addEventListener('pause', handlePause);\n    video.addEventListener('ended', handleEnded);\n    video.addEventListener('error', handleError);\n    video.addEventListener('waiting', handleWaiting);\n    video.addEventListener('stalled', handleStalled);\n\n    // Cleanup\n    return () => {\n      video.removeEventListener('loadedmetadata', handleLoadedMetadata);\n      video.removeEventListener('loadeddata', handleLoadedData);\n      video.removeEventListener('canplay', handleCanPlay);\n      video.removeEventListener('play', handlePlay);\n      video.removeEventListener('pause', handlePause);\n      video.removeEventListener('ended', handleEnded);\n      video.removeEventListener('error', handleError);\n      video.removeEventListener('waiting', handleWaiting);\n      video.removeEventListener('stalled', handleStalled);\n    };\n  }, [internalRef]);\n\n  return <video ref={internalRef} className={className} aria-label='Screen sharing video stream' {...props} />;\n});\n\nVideoPlayer.displayName = 'VideoPlayer';\n\nexport default VideoPlayer;\n","/**\n * TURN Server Configuration\n * Provides STUN and TURN servers for WebRTC connections\n */\n\n// Default STUN servers (free, no authentication required)\nconst DEFAULT_STUN_SERVERS = [\n  { urls: 'stun:stun.l.google.com:19302' },\n  { urls: 'stun:stun1.l.google.com:19302' },\n  { urls: 'stun:stun2.l.google.com:19302' },\n  { urls: 'stun:stun3.l.google.com:19302' },\n  { urls: 'stun:stun4.l.google.com:19302' },\n];\n\n// TURN servers (require authentication and may have costs)\nconst TURN_SERVERS = [\n  // Free TURN server for testing (may have limitations)\n  {\n    urls: 'turn:openrelay.metered.ca:80',\n    username: 'openrelayproject',\n    credential: 'openrelayproject',\n  },\n  {\n    urls: 'turn:openrelay.metered.ca:443',\n    username: 'openrelayproject',\n    credential: 'openrelayproject',\n  },\n  {\n    urls: 'turn:openrelay.metered.ca:443?transport=tcp',\n    username: 'openrelayproject',\n    credential: 'openrelayproject',\n  },\n  // Production TURN servers (if configured)\n  ...(process.env.TURN_SERVERS ? JSON.parse(process.env.TURN_SERVERS) : []),\n];\n\n/**\n * Get ICE servers configuration for WebRTC\n * @param {boolean} includeTurn - Whether to include TURN servers\n * @returns {Array} Array of ICE server configurations\n */\nexport function getIceServers(includeTurn = false) {\n  const iceServers = [...DEFAULT_STUN_SERVERS];\n\n  if (includeTurn && TURN_SERVERS.length > 0) {\n    iceServers.push(...TURN_SERVERS);\n  }\n\n  return iceServers;\n}\n\n/**\n * Get STUN servers only (for basic connectivity)\n * @returns {Array} Array of STUN server configurations\n */\nexport function getStunServers() {\n  return DEFAULT_STUN_SERVERS;\n}\n\n/**\n * Check if TURN servers are configured\n * @returns {boolean} True if TURN servers are available\n */\nexport function hasTurnServers() {\n  return TURN_SERVERS.length > 0 && process.env.TURN_USERNAME && process.env.TURN_PASSWORD;\n}\n\n/**\n * Get connection quality based on ICE gathering state\n * @param {RTCPeerConnection} peerConnection - The peer connection to check\n * @returns {string} Connection quality ('excellent', 'good', 'poor', 'unknown')\n */\nexport function getConnectionQuality(peerConnection) {\n  if (!peerConnection) return 'unknown';\n\n  // This is a simplified implementation\n  // In a real app, you'd analyze the stats for connection quality\n\n  switch (peerConnection.connectionState) {\n    case 'connected':\n      return 'excellent';\n    case 'connecting':\n      return 'good';\n    case 'disconnected':\n    case 'failed':\n      return 'poor';\n    default:\n      return 'unknown';\n  }\n}\n\n/**\n * Configure WebRTC with optimal settings\n * @param {RTCPeerConnection} peerConnection - The peer connection to configure\n * @param {boolean} useTurn - Whether to use TURN servers\n * @param {string} transportPolicy - ICE transport policy ('all' or 'relay')\n */\nexport function configureWebRTC(peerConnection, useTurn = false, transportPolicy = null) {\n  if (!peerConnection) return;\n\n  // Get transport policy from environment or use default\n  const iceTransportPolicy = transportPolicy || process.env.ICE_TRANSPORT_POLICY || (useTurn ? 'all' : 'all');\n\n  // Set ICE servers\n  peerConnection.setConfiguration({\n    iceServers: getIceServers(useTurn),\n    iceCandidatePoolSize: 10,\n    iceTransportPolicy,\n    bundlePolicy: 'max-bundle',\n    rtcpMuxPolicy: 'require',\n  });\n\n  // Configure ICE gathering\n  peerConnection.addEventListener('icegatheringstatechange', () => {\n    console.log('ICE gathering state:', peerConnection.iceGatheringState);\n  });\n\n  peerConnection.addEventListener('iceconnectionstatechange', () => {\n    console.log('ICE connection state:', peerConnection.iceConnectionState);\n  });\n}\n\nexport default {\n  getIceServers,\n  getStunServers,\n  hasTurnServers,\n  getConnectionQuality,\n  configureWebRTC,\n};\n","/**\n * Logger Utility\n * Centralized logging with environment-aware levels\n */\n\nconst isDevelopment =\n  import.meta.env.DEV ||\n  import.meta.env.MODE === 'development' ||\n  import.meta.env.MODE === 'test' ||\n  window.location.hostname === 'localhost' ||\n  window.location.hostname.includes('localhost');\n\n// const isProduction = import.meta.env.PROD ||\n//   import.meta.env.MODE === 'production';\n\n/**\n * Log levels\n */\nconst LOG_LEVELS = {\n  ERROR: 0,\n  WARN: 1,\n  INFO: 2,\n  DEBUG: 3,\n};\n\n/**\n * Current log level based on environment\n */\nconst currentLogLevel = isDevelopment ? LOG_LEVELS.DEBUG : LOG_LEVELS.ERROR;\n\n/**\n * Logger class\n */\nclass Logger {\n  static error(message, ...args) {\n    if (currentLogLevel >= LOG_LEVELS.ERROR) {\n      console.error(`[ERROR] ${message}`, ...args);\n    }\n  }\n\n  static warn(message, ...args) {\n    if (currentLogLevel >= LOG_LEVELS.WARN) {\n      console.warn(`[WARN] ${message}`, ...args);\n    }\n  }\n\n  static info(message, ...args) {\n    if (currentLogLevel >= LOG_LEVELS.INFO) {\n      console.info(`[INFO] ${message}`, ...args);\n    }\n  }\n\n  static debug(message, ...args) {\n    if (currentLogLevel >= LOG_LEVELS.DEBUG) {\n      console.debug(`[DEBUG] ${message}`, ...args);\n    }\n  }\n\n  /**\n   * Log WebRTC events (only in development)\n   */\n  static webrtc(event, data = {}) {\n    if (isDevelopment) {\n      console.debug(`[WebRTC] ${event}`, data);\n    }\n  }\n\n  /**\n   * Log API calls (only in development)\n   */\n  static api(method, endpoint, data = {}) {\n    if (isDevelopment) {\n      console.debug(`[API] ${method} ${endpoint}`, data);\n    }\n  }\n\n  /**\n   * Log user actions (only in development)\n   */\n  static user(action, data = {}) {\n    if (isDevelopment) {\n      console.debug(`[USER] ${action}`, data);\n    }\n  }\n}\n\n// Export the static class directly\nexport default Logger;\n","/**\n * Application Constants\n * Centralized constants to prevent magic strings and improve maintainability\n */\n\n// Connection States\nexport const CONNECTION_STATES = {\n  DISCONNECTED: 'disconnected',\n  CONNECTING: 'connecting',\n  CONNECTED: 'connected',\n  FAILED: 'failed',\n};\n\n// User Roles\nexport const ROLES = {\n  HOST: 'host',\n  VIEWER: 'viewer',\n};\n\n// UI States\nexport const UI_STATES = {\n  HOME: 'home',\n  HOST: 'host',\n  VIEWER: 'viewer',\n};\n\n// Copy Status\nexport const COPY_STATUS = {\n  SUCCESS: 'success',\n  ERROR: 'error',\n};\n\n// Error Messages\nexport const ERROR_MESSAGES = {\n  ROOM_NOT_FOUND: 'Room not found. Please check the room ID and make sure the host has started sharing.',\n  CONNECTION_FAILED: 'Failed to connect to host. Please check the room ID and try again.',\n  SCREEN_SHARE_FAILED: 'Failed to start screen sharing. Please check your browser permissions.',\n  INVALID_ROOM_ID: 'Room ID must be exactly 24 characters and contain only letters and numbers',\n  INVALID_VIEWER_ID: 'Viewer ID can only contain letters, numbers, spaces, hyphens, and underscores',\n  CONNECTION_TIMEOUT: 'Connection timeout. Please try again.',\n};\n\n// Success Messages\nexport const SUCCESS_MESSAGES = {\n  ROOM_CREATED: 'Room created successfully',\n  CONNECTION_ESTABLISHED: 'Connected to host',\n  SCREEN_SHARING_STARTED: 'Screen sharing started',\n};\n\n// UI Text\nexport const UI_TEXT = {\n  START_SHARING: 'Start Sharing',\n  STOP_SHARING: 'Stop Sharing',\n  CONNECT_TO_HOST: 'Connect to Host',\n  DISCONNECT: 'Disconnect',\n  RECONNECT: 'Reconnect',\n  COPY: 'Copy',\n  COPIED: 'Copied!',\n  FAILED: 'Failed!',\n  CONNECTING: 'Connecting...',\n  CONNECTED: 'Connected',\n  DISCONNECTED: 'Disconnected',\n  HOST_ONLINE: 'Host Online',\n  HOST_OFFLINE: 'Host Offline',\n  CONNECTING_TO_HOST: 'Connecting to Host...',\n  UNKNOWN: 'Unknown',\n};\n\n// Status Colors (Tailwind classes)\nexport const STATUS_COLORS = {\n  SUCCESS: 'text-green-600',\n  WARNING: 'text-yellow-600',\n  ERROR: 'text-red-600',\n  INFO: 'text-blue-600',\n  DEFAULT: 'text-gray-600',\n};\n\n// Background Colors (Tailwind classes)\nexport const BACKGROUND_COLORS = {\n  SUCCESS: 'bg-green-600',\n  WARNING: 'bg-yellow-600',\n  ERROR: 'bg-red-600',\n  INFO: 'bg-blue-600',\n  DEFAULT: 'bg-gray-600',\n};\n\n// Validation Rules\nexport const VALIDATION_RULES = {\n  ROOM_ID_LENGTH: 24,\n  VIEWER_ID_MIN_LENGTH: 3,\n  VIEWER_ID_MAX_LENGTH: 50,\n  MESSAGE_MAX_LENGTH: 500,\n  SENDER_MAX_LENGTH: 50,\n};\n\n// Polling Intervals (milliseconds)\nexport const POLLING_INTERVALS = {\n  DEFAULT: 1000,\n  REDUCED: 5000,\n  CANDIDATE_TIMEOUT: 120000, // 2 minutes\n  OFFER_TIMEOUT: 60000, // 1 minute\n  ANSWER_TIMEOUT: 60000, // 1 minute\n};\n\n// UI Delays (milliseconds)\nexport const UI_DELAYS = {\n  COPY_FEEDBACK: 2000,\n  RECONNECT_DELAY: 1000,\n};\n\n// Redis Keys\nexport const REDIS_KEYS = {\n  ROOM_META: (roomId) => `room:${roomId}:meta`,\n  ROOM_OFFER: (roomId) => `room:${roomId}:offer`,\n  ROOM_ANSWER: (roomId) => `room:${roomId}:answer`,\n  ROOM_CANDIDATES: (roomId, role, viewerId) =>\n    role === ROLES.VIEWER && viewerId\n      ? `room:${roomId}:${role}:${viewerId}:candidates`\n      : `room:${roomId}:${role}:candidates`,\n  ROOM_CHAT: (roomId) => `room:${roomId}:chat`,\n  ROOM_SENDER: (roomId, senderId) => `room:${roomId}:sender:${senderId}`,\n};\n\n// API Endpoints\nexport const API_ENDPOINTS = {\n  CONFIG: '/api/config',\n  CREATE_ROOM: '/api/create-room',\n  OFFER: '/api/offer',\n  ANSWER: '/api/answer',\n  CANDIDATE: '/api/candidate',\n  CHAT: '/api/chat',\n  DIAGNOSTICS: '/api/diagnostics',\n  VIEWERS: '/api/viewers',\n  REGISTER_SENDER: '/api/register-sender',\n};\n","/**\n * Polling Utilities\n * Provides exponential backoff and timeout functionality for polling operations\n */\n\nimport { POLLING_INTERVALS } from '../constants';\n\n/**\n * Create a polling function with exponential backoff\n * @param {Function} pollFn - The function to call for polling\n * @param {Object} options - Polling options\n * @param {number} options.initialInterval - Initial polling interval in ms\n * @param {number} options.maxInterval - Maximum polling interval in ms\n * @param {number} options.backoffFactor - Factor to multiply interval by on backoff\n * @param {number} options.maxPolls - Maximum number of polls before timeout\n * @param {number} options.backoffAfter - Number of polls before starting backoff\n * @returns {Function} - Polling function that returns a promise\n */\nexport function createExponentialBackoffPolling(pollFn, options = {}) {\n  const {\n    initialInterval = POLLING_INTERVALS.DEFAULT,\n    maxInterval = 30000, // 30 seconds max\n    backoffFactor = 1.5,\n    maxPolls = 60,\n    backoffAfter = 10,\n  } = options;\n\n  return async () => {\n    let pollCount = 0;\n    let currentInterval = initialInterval;\n\n    const poll = async () => {\n      pollCount++;\n\n      // Check timeout\n      if (pollCount > maxPolls) {\n        throw new Error('Polling timeout reached');\n      }\n\n      // Execute the polling function\n      const result = await pollFn();\n\n      // If we get a result, return it\n      if (result) {\n        return result;\n      }\n\n      // If no result and we've hit the backoff threshold, increase interval\n      if (pollCount > backoffAfter) {\n        currentInterval = Math.min(currentInterval * backoffFactor, maxInterval);\n      }\n\n      // Schedule next poll\n      return new Promise((resolve, reject) => {\n        const timeoutId = setTimeout(async () => {\n          try {\n            const nextResult = await poll();\n            resolve(nextResult);\n          } catch (error) {\n            reject(error);\n          }\n        }, currentInterval);\n\n        // Store timeout ID for potential cleanup\n        poll.timeoutId = timeoutId;\n      });\n    };\n\n    return poll();\n  };\n}\n\n/**\n * Create a simple polling function with timeout\n * @param {Function} pollFn - The function to call for polling\n * @param {Object} options - Polling options\n * @param {number} options.interval - Polling interval in ms\n * @param {number} options.maxPolls - Maximum number of polls before timeout\n * @returns {Function} - Polling function that returns a promise\n */\nexport function createSimplePolling(pollFn, options = {}) {\n  const { interval = POLLING_INTERVALS.DEFAULT, maxPolls = 60 } = options;\n\n  return async () => {\n    let pollCount = 0;\n\n    const poll = async () => {\n      pollCount++;\n\n      // Check timeout\n      if (pollCount > maxPolls) {\n        throw new Error('Polling timeout reached');\n      }\n\n      // Execute the polling function\n      const result = await pollFn();\n\n      // If we get a result, return it\n      if (result) {\n        return result;\n      }\n\n      // Schedule next poll\n      return new Promise((resolve, reject) => {\n        const timeoutId = setTimeout(async () => {\n          try {\n            const nextResult = await poll();\n            resolve(nextResult);\n          } catch (error) {\n            reject(error);\n          }\n        }, interval);\n\n        // Store timeout ID for potential cleanup\n        poll.timeoutId = timeoutId;\n      });\n    };\n\n    return poll();\n  };\n}\n\n/**\n * Stop a polling function by clearing its timeout\n * @param {Function} pollFn - The polling function to stop\n */\nexport function stopPolling(pollFn) {\n  if (pollFn.timeoutId) {\n    clearTimeout(pollFn.timeoutId);\n    pollFn.timeoutId = null;\n  }\n}\n","import { useState, useEffect, useRef, useCallback } from 'react';\nimport { getIceServers } from '../config/turn.js';\nimport logger from '../utils/logger';\nimport { createExponentialBackoffPolling } from '../utils/polling';\n\nexport function useWebRTC(roomId, role, config, _viewerId = null) {\n  // State\n  const [connectionState, setConnectionState] = useState('disconnected');\n  const [remoteStream, setRemoteStream] = useState(null);\n  const [localStream, setLocalStream] = useState(null);\n  const [error, setError] = useState(null);\n  const [iceServers, setIceServers] = useState([]);\n  \n  // Multi-viewer support: Map of viewerId to peer connections\n  const [peerConnections, setPeerConnections] = useState(new Map());\n  const [viewerCount, setViewerCount] = useState(0);\n  \n  // Granular error state for better user feedback\n  const [errorState, setErrorState] = useState({\n    type: null, // 'permission', 'network', 'webrtc', 'timeout', 'unknown'\n    code: null, // Specific error code\n    message: null, // User-friendly message\n    details: null, // Technical details for debugging\n  });\n\n  // Refs\n  const peerConnectionRef = useRef(null);\n  const dataChannelRef = useRef(null);\n  const offerIntervalRef = useRef(null);\n  const answerIntervalRef = useRef(null);\n  const candidateIntervalRef = useRef(null);\n  const isMountedRef = useRef(true);\n\n  // Initialize ICE servers\n  useEffect(() => {\n    // Use TURN server configuration by default for better connectivity\n    const servers = getIceServers(config?.useTurn !== false); // Default to true unless explicitly disabled\n    setIceServers(servers);\n  }, [config]);\n\n  // Helper function to set granular error state\n  const setGranularError = useCallback((type, code, message, details = null) => {\n    setErrorState({ type, code, message, details });\n    setError(message);\n    logger.error(`WebRTC Error [${type}]: ${message}`, { code, details });\n  }, []);\n\n  // Send ICE candidate\n  const sendICECandidate = useCallback(\n    async (candidate) => {\n      if (!roomId || !role) return;\n\n      try {\n        const response = await fetch('/api/candidate', {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            ...(config?.authSecret && { 'x-auth-secret': config.authSecret }),\n          },\n          body: JSON.stringify({\n            roomId,\n            role,\n            viewerId: _viewerId, // Include viewer ID for proper identification\n            candidate: candidate, // Send RTCIceCandidate directly\n          }),\n        });\n\n        if (!response.ok) {\n          throw new Error(`Failed to send ICE candidate: ${response.status}`);\n        }\n      } catch (err) {\n        logger.error('Error sending ICE candidate:', err);\n        setError(`Failed to send ICE candidate: ${err.message}`);\n      }\n    },\n    [roomId, role, config, _viewerId] // Fixed: Added _viewerId to dependency array\n  );\n\n  // Create peer connection\n  const createPeerConnection = useCallback(() => {\n    const pc = new RTCPeerConnection({\n      iceServers,\n    });\n\n    // Handle ICE candidates\n    pc.onicecandidate = (event) => {\n      if (event.candidate) {\n        sendICECandidate(event.candidate);\n      }\n    };\n\n    // Handle connection state changes\n    pc.onconnectionstatechange = () => {\n      logger.webrtc('Connection state changed', { state: pc.connectionState });\n      setConnectionState(pc.connectionState);\n\n      // Clear polling intervals when connected or failed\n      if (pc.connectionState === 'connected' || pc.connectionState === 'failed') {\n        if (offerIntervalRef.current) {\n          clearInterval(offerIntervalRef.current);\n          offerIntervalRef.current = null;\n        }\n        if (answerIntervalRef.current) {\n          clearInterval(answerIntervalRef.current);\n          answerIntervalRef.current = null;\n        }\n        if (candidateIntervalRef.current) {\n          clearInterval(candidateIntervalRef.current);\n          candidateIntervalRef.current = null;\n        }\n      }\n    };\n\n    // Handle ICE connection state changes\n    pc.oniceconnectionstatechange = () => {\n      logger.webrtc('ICE connection state changed', { state: pc.iceConnectionState });\n    };\n\n    // Handle remote stream\n    pc.ontrack = (event) => {\n      logger.webrtc('Received remote stream', { stream: event.streams[0] });\n      setRemoteStream(event.streams[0]);\n    };\n\n    // Handle data channel\n    pc.ondatachannel = (event) => {\n      const channel = event.channel;\n      dataChannelRef.current = channel;\n\n      channel.onopen = () => {\n        logger.webrtc('Data channel opened');\n      };\n\n      channel.onmessage = (event) => {\n        logger.webrtc('Received data channel message', { data: event.data });\n      };\n    };\n\n    return pc;\n  }, [iceServers, sendICECandidate]);\n\n  // Send offer\n  const sendOffer = useCallback(\n    async (offer) => {\n      if (!roomId) return;\n\n      try {\n        const response = await fetch('/api/offer', {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            ...(config?.authSecret && { 'x-auth-secret': config.authSecret }),\n          },\n          body: JSON.stringify({\n            roomId,\n            desc: offer,\n          }),\n        });\n\n        if (!response.ok) {\n          throw new Error(`Failed to send offer: ${response.status}`);\n        }\n      } catch (err) {\n        logger.error('Error sending offer:', err);\n        setError(`Failed to send offer: ${err.message}`);\n      }\n    },\n    [roomId, config]\n  );\n\n  // Send answer\n  const sendAnswer = useCallback(\n    async (answer) => {\n      if (!roomId) return;\n\n      try {\n        const response = await fetch('/api/answer', {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            ...(config?.authSecret && { 'x-auth-secret': config.authSecret }),\n          },\n          body: JSON.stringify({\n            roomId,\n            desc: answer,\n          }),\n        });\n\n        if (!response.ok) {\n          throw new Error(`Failed to send answer: ${response.status}`);\n        }\n      } catch (err) {\n        logger.error('Error sending answer:', err);\n        setError(`Failed to send answer: ${err.message}`);\n      }\n    },\n    [roomId, config]\n  );\n\n  // Start polling for offers (viewer)\n  const startOfferPolling = useCallback(async () => {\n    if (offerIntervalRef.current) {\n      clearInterval(offerIntervalRef.current);\n    }\n\n    let pollCount = 0;\n    let pollInterval = 1000; // Start with 1 second\n    const maxPolls = 60; // 60 seconds timeout\n\n    const pollForOffer = async () => {\n      try {\n        pollCount++;\n\n        // Timeout after maxPolls attempts\n        if (pollCount > maxPolls) {\n          clearInterval(offerIntervalRef.current);\n          offerIntervalRef.current = null;\n          if (isMountedRef.current) {\n            setError('Connection timeout: No offer received from host. Make sure the host has started sharing.');\n            setConnectionState('failed');\n          }\n          return;\n        }\n\n        const response = await fetch(`/api/offer?roomId=${roomId}`);\n\n        if (response.ok) {\n          const data = await response.json();\n          if (data.desc) {\n            // Clear interval once we get an offer\n            clearInterval(offerIntervalRef.current);\n            offerIntervalRef.current = null;\n\n            // Create peer connection when we receive an offer\n            const pc = createPeerConnection();\n            peerConnectionRef.current = pc;\n\n            // Handle the offer\n            await pc.setRemoteDescription(data.desc);\n\n            // Create and send answer\n            const answer = await pc.createAnswer();\n            await pc.setLocalDescription(answer);\n            await sendAnswer(answer);\n\n            // Start ICE candidate polling now that we have a peer connection\n            startCandidatePolling();\n          }\n        } else if (response.status === 404) {\n          // Expected 404 - no offer yet, but reduce polling frequency after initial attempts\n          if (pollCount > 10) {\n            // After 10 seconds, reduce to polling every 5 seconds\n            clearInterval(offerIntervalRef.current);\n            pollInterval = 5000;\n            offerIntervalRef.current = setInterval(pollForOffer, pollInterval);\n          }\n        } else {\n          // Unexpected error\n          logger.error('Unexpected error polling for offers:', response.status);\n          clearInterval(offerIntervalRef.current);\n          offerIntervalRef.current = null;\n          if (isMountedRef.current) {\n            setError(`Server error: ${response.status}`);\n            setConnectionState('failed');\n          }\n        }\n      } catch (err) {\n        logger.error('Error polling for offers:', err);\n        clearInterval(offerIntervalRef.current);\n        offerIntervalRef.current = null;\n        if (isMountedRef.current) {\n          setError(`Network error: ${err.message}`);\n          setConnectionState('failed');\n        }\n      }\n    };\n\n    offerIntervalRef.current = setInterval(pollForOffer, pollInterval);\n  }, [roomId, sendAnswer, createPeerConnection, startCandidatePolling]);\n\n  // Start polling for answers (host)\n  const startAnswerPolling = useCallback(async () => {\n    if (answerIntervalRef.current) {\n      clearInterval(answerIntervalRef.current);\n    }\n\n    let pollCount = 0;\n    let pollInterval = 1000; // Start with 1 second\n    const maxPolls = 60; // 60 seconds timeout\n\n    const pollForAnswer = async () => {\n      try {\n        pollCount++;\n\n        // Timeout after maxPolls attempts\n        if (pollCount > maxPolls) {\n          clearInterval(answerIntervalRef.current);\n          answerIntervalRef.current = null;\n          if (isMountedRef.current) {\n            setError('Connection timeout: No answer received from viewer. Make sure the viewer has connected.');\n            setConnectionState('failed');\n          }\n          return;\n        }\n\n        const response = await fetch(`/api/answer?roomId=${roomId}`);\n\n        if (response.ok) {\n          const data = await response.json();\n          if (data.desc) {\n            // Clear interval once we get an answer\n            clearInterval(answerIntervalRef.current);\n            answerIntervalRef.current = null;\n\n            // Handle the answer\n            const pc = peerConnectionRef.current;\n            if (pc) {\n              await pc.setRemoteDescription(data.desc);\n            }\n          }\n        } else if (response.status === 404) {\n          // Expected 404 - no answer yet, but reduce polling frequency after initial attempts\n          if (pollCount > 10) {\n            // After 10 seconds, reduce to polling every 5 seconds\n            clearInterval(answerIntervalRef.current);\n            pollInterval = 5000;\n            answerIntervalRef.current = setInterval(pollForAnswer, pollInterval);\n          }\n        } else {\n          // Unexpected error\n          logger.error('Unexpected error polling for answers:', response.status);\n          clearInterval(answerIntervalRef.current);\n          answerIntervalRef.current = null;\n          if (isMountedRef.current) {\n            setError(`Server error: ${response.status}`);\n            setConnectionState('failed');\n          }\n        }\n      } catch (err) {\n        logger.error('Error polling for answers:', err);\n        clearInterval(answerIntervalRef.current);\n        answerIntervalRef.current = null;\n        if (isMountedRef.current) {\n          setError(`Network error: ${err.message}`);\n          setConnectionState('failed');\n        }\n      }\n    };\n\n    answerIntervalRef.current = setInterval(pollForAnswer, pollInterval);\n  }, [roomId]);\n\n  // Start polling for ICE candidates with exponential backoff\n  const startCandidatePolling = useCallback(async () => {\n    if (candidateIntervalRef.current) {\n      clearInterval(candidateIntervalRef.current);\n    }\n\n    const pollFn = async () => {\n      const response = await fetch(\n        `/api/candidate?roomId=${roomId}&role=${role}${_viewerId ? `&viewerId=${_viewerId}` : ''}`\n      );\n\n      if (response.ok) {\n        const data = await response.json();\n        if (data.candidates && data.candidates.length > 0) {\n          const pc = peerConnectionRef.current;\n          if (pc) {\n            for (const candidate of data.candidates) {\n              try {\n                await pc.addIceCandidate(candidate);\n              } catch (candidateErr) {\n                logger.warn('Failed to add ICE candidate:', candidateErr);\n              }\n            }\n          }\n          return true; // Found candidates\n        }\n      } else if (response.status !== 404) {\n        // 404 is expected when no candidates, but other errors are concerning\n        logger.error('Error polling for ICE candidates:', response.status);\n        throw new Error(`HTTP ${response.status}`);\n      }\n\n      return false; // No candidates found\n    };\n\n    const pollingFunction = createExponentialBackoffPolling(pollFn, {\n      initialInterval: 1000,\n      maxInterval: 10000, // 10 seconds max\n      backoffFactor: 1.5,\n      maxPolls: 120, // 2 minutes timeout\n      backoffAfter: 10, // Start backoff after 10 polls\n    });\n\n    try {\n      await pollingFunction();\n    } catch (error) {\n      logger.warn('ICE candidate polling timeout - connection may be stuck');\n    }\n  }, [roomId, role, _viewerId]); // Fixed: Added _viewerId to dependency array\n\n  // Start screen sharing (host)\n  const startScreenShare = useCallback(async () => {\n    if (role !== 'host') {\n      throw new Error('Only hosts can start screen sharing');\n    }\n\n    try {\n      setError(null);\n      setConnectionState('connecting');\n\n      // Get screen share stream\n      const stream = await navigator.mediaDevices.getDisplayMedia({\n        video: true,\n        audio: true,\n      });\n\n      // Check what permissions were actually granted\n      const videoTracks = stream.getVideoTracks();\n      const audioTracks = stream.getAudioTracks();\n      \n      if (videoTracks.length === 0) {\n        setGranularError(\n          'permission',\n          'VIDEO_DENIED',\n          'Video permission is required to share your screen. Please allow video access and try again.',\n          'User denied video permission in getDisplayMedia'\n        );\n        throw new Error('Video permission denied - cannot share screen without video');\n      }\n      \n      if (audioTracks.length === 0) {\n        logger.warn('Audio permission denied - screen sharing will be video-only');\n        // Don't throw error for audio - video-only is acceptable\n      }\n\n      setLocalStream(stream);\n\n      // Create peer connection\n      const pc = createPeerConnection();\n      peerConnectionRef.current = pc;\n\n      // Add transceivers to peer connection (modern WebRTC approach)\n      stream.getTracks().forEach((track) => {\n        pc.addTransceiver(track, {\n          streams: [stream],\n          direction: 'sendonly', // Host sends media to viewers\n        });\n      });\n\n      // Create and send offer\n      const offer = await pc.createOffer({\n        offerToReceiveAudio: true,\n        offerToReceiveVideo: true,\n      });\n\n      await pc.setLocalDescription(offer);\n      await sendOffer(offer);\n\n      // Start polling for answers\n      startAnswerPolling();\n\n      // Start polling for ICE candidates\n      startCandidatePolling();\n\n      return stream;\n    } catch (err) {\n      logger.error('Error starting screen share:', err);\n      setError(`Failed to start screen sharing: ${err.message}`);\n      setConnectionState('disconnected');\n      throw err;\n    }\n  }, [role, createPeerConnection, sendOffer, startAnswerPolling, startCandidatePolling]);\n\n  // Connect to host (viewer)\n  const connectToHost = useCallback(async () => {\n    if (role !== 'viewer') {\n      throw new Error('Only viewers can connect to host');\n    }\n\n    try {\n      setError(null);\n      setConnectionState('connecting');\n\n      // Don't create peer connection yet - wait for offer from host\n      // Start polling for offers (ICE candidate polling will start when peer connection is created)\n      startOfferPolling();\n    } catch (err) {\n      logger.error('Error connecting to host:', err);\n      setError(`Failed to connect to host: ${err.message}`);\n      setConnectionState('disconnected');\n      throw err;\n    }\n  }, [role, startOfferPolling]);\n\n  // Stop screen sharing\n  const stopScreenShare = useCallback(async () => {\n    try {\n      // Stop local stream\n      if (localStream) {\n        localStream.getTracks().forEach((track) => track.stop());\n        setLocalStream(null);\n      }\n\n      // Close peer connection\n      if (peerConnectionRef.current) {\n        peerConnectionRef.current.close();\n        peerConnectionRef.current = null;\n      }\n\n      // Clear intervals\n      if (offerIntervalRef.current) {\n        clearInterval(offerIntervalRef.current);\n        offerIntervalRef.current = null;\n      }\n\n      if (answerIntervalRef.current) {\n        clearInterval(answerIntervalRef.current);\n        answerIntervalRef.current = null;\n      }\n\n      if (candidateIntervalRef.current) {\n        clearInterval(candidateIntervalRef.current);\n        candidateIntervalRef.current = null;\n      }\n\n      setConnectionState('disconnected');\n      setRemoteStream(null);\n    } catch (err) {\n      logger.error('Error stopping screen share:', err);\n      setError(`Failed to stop screen sharing: ${err.message}`);\n    }\n  }, [localStream]);\n\n  // Disconnect\n  const disconnect = useCallback(async () => {\n    await stopScreenShare();\n  }, [stopScreenShare]);\n\n  // Start polling for offers (viewer)\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      isMountedRef.current = false; // Mark component as unmounted\n\n      if (offerIntervalRef.current) {\n        clearInterval(offerIntervalRef.current);\n      }\n      if (answerIntervalRef.current) {\n        clearInterval(answerIntervalRef.current);\n      }\n      if (candidateIntervalRef.current) {\n        clearInterval(candidateIntervalRef.current);\n      }\n      if (peerConnectionRef.current) {\n        peerConnectionRef.current.close();\n      }\n      if (localStream) {\n        localStream.getTracks().forEach((track) => track.stop());\n      }\n    };\n  }, [localStream]);\n\n  return {\n    // State\n    connectionState,\n    remoteStream,\n    localStream,\n    error,\n    errorState, // Granular error state for better UI feedback\n    peerConnections, // Multi-viewer support\n    viewerCount, // Number of connected viewers\n\n    // Actions\n    startScreenShare,\n    stopScreenShare,\n    connectToHost,\n    disconnect,\n  };\n}\n"],"names":["VideoPlayer","forwardRef","className","props","ref","videoRef","useRef","internalRef","useImperativeHandle","useEffect","video","handleLoadedMetadata","handleLoadedData","handleCanPlay","handlePlay","handlePause","handleEnded","handleError","e","handleWaiting","handleStalled","jsx","DEFAULT_STUN_SERVERS","TURN_SERVERS","define_process_env_default","getIceServers","includeTurn","iceServers","isDevelopment","LOG_LEVELS","currentLogLevel","Logger","message","args","event","data","method","endpoint","action","CONNECTION_STATES","ERROR_MESSAGES","UI_TEXT","STATUS_COLORS","POLLING_INTERVALS","API_ENDPOINTS","createExponentialBackoffPolling","pollFn","options","initialInterval","maxInterval","backoffFactor","maxPolls","backoffAfter","pollCount","currentInterval","poll","result","resolve","reject","timeoutId","nextResult","error","useWebRTC","roomId","role","config","_viewerId","connectionState","setConnectionState","useState","remoteStream","setRemoteStream","localStream","setLocalStream","setError","setIceServers","peerConnections","setPeerConnections","viewerCount","setViewerCount","errorState","setErrorState","peerConnectionRef","dataChannelRef","offerIntervalRef","answerIntervalRef","candidateIntervalRef","isMountedRef","servers","setGranularError","useCallback","type","code","details","logger","sendICECandidate","candidate","response","err","createPeerConnection","pc","channel","sendOffer","offer","sendAnswer","answer","startOfferPolling","pollInterval","pollForOffer","startCandidatePolling","startAnswerPolling","pollForAnswer","pollingFunction","candidateErr","startScreenShare","stream","videoTracks","audioTracks","track","connectToHost","stopScreenShare","disconnect"],"mappings":"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"}