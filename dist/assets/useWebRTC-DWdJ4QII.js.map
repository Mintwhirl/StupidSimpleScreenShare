{"version":3,"file":"useWebRTC-DWdJ4QII.js","sources":["../../src/components/VideoPlayer.jsx","../../src/config/turn.js","../../src/hooks/useWebRTC.js"],"sourcesContent":["import { forwardRef, useEffect, useRef } from 'react';\n\nconst VideoPlayer = forwardRef(({ className, ...props }, ref) => {\n  const videoRef = useRef(null);\n  const internalRef = ref || videoRef;\n\n  // Handle video element events\n  useEffect(() => {\n    const video = internalRef.current;\n    if (!video) return;\n\n    const handleLoadedMetadata = () => {\n      console.log('Video metadata loaded:', {\n        duration: video.duration,\n        videoWidth: video.videoWidth,\n        videoHeight: video.videoHeight,\n      });\n    };\n\n    const handleLoadedData = () => {\n      console.log('Video data loaded');\n    };\n\n    const handleCanPlay = () => {\n      console.log('Video can start playing');\n    };\n\n    const handlePlay = () => {\n      console.log('Video started playing');\n    };\n\n    const handlePause = () => {\n      console.log('Video paused');\n    };\n\n    const handleEnded = () => {\n      console.log('Video ended');\n    };\n\n    const handleError = (e) => {\n      console.error('Video error:', e);\n    };\n\n    const handleWaiting = () => {\n      console.log('Video waiting for data');\n    };\n\n    const handleStalled = () => {\n      console.log('Video stalled');\n    };\n\n    // Add event listeners\n    video.addEventListener('loadedmetadata', handleLoadedMetadata);\n    video.addEventListener('loadeddata', handleLoadedData);\n    video.addEventListener('canplay', handleCanPlay);\n    video.addEventListener('play', handlePlay);\n    video.addEventListener('pause', handlePause);\n    video.addEventListener('ended', handleEnded);\n    video.addEventListener('error', handleError);\n    video.addEventListener('waiting', handleWaiting);\n    video.addEventListener('stalled', handleStalled);\n\n    // Cleanup\n    return () => {\n      video.removeEventListener('loadedmetadata', handleLoadedMetadata);\n      video.removeEventListener('loadeddata', handleLoadedData);\n      video.removeEventListener('canplay', handleCanPlay);\n      video.removeEventListener('play', handlePlay);\n      video.removeEventListener('pause', handlePause);\n      video.removeEventListener('ended', handleEnded);\n      video.removeEventListener('error', handleError);\n      video.removeEventListener('waiting', handleWaiting);\n      video.removeEventListener('stalled', handleStalled);\n    };\n  }, [internalRef]);\n\n  return <video ref={internalRef} className={className} {...props} />;\n});\n\nVideoPlayer.displayName = 'VideoPlayer';\n\nexport default VideoPlayer;\n","/**\r\n * TURN Server Configuration\r\n * Provides STUN and TURN servers for WebRTC connections\r\n */\r\n\r\n// Default STUN servers (free, no authentication required)\r\nconst DEFAULT_STUN_SERVERS = [\r\n  { urls: 'stun:stun.l.google.com:19302' },\r\n  { urls: 'stun:stun1.l.google.com:19302' },\r\n  { urls: 'stun:stun2.l.google.com:19302' },\r\n  { urls: 'stun:stun3.l.google.com:19302' },\r\n  { urls: 'stun:stun4.l.google.com:19302' },\r\n];\r\n\r\n// TURN servers (require authentication and may have costs)\r\nconst TURN_SERVERS = [\r\n  // Example TURN server configuration\r\n  // Replace with your actual TURN server credentials\r\n  {\r\n    urls: 'turn:your-turn-server.com:3478',\r\n    username: process.env.TURN_USERNAME || 'your-username',\r\n    credential: process.env.TURN_PASSWORD || 'your-password',\r\n  },\r\n  // Add more TURN servers as needed\r\n];\r\n\r\n/**\r\n * Get ICE servers configuration for WebRTC\r\n * @param {boolean} includeTurn - Whether to include TURN servers\r\n * @returns {Array} Array of ICE server configurations\r\n */\r\nexport function getIceServers(includeTurn = false) {\r\n  const iceServers = [...DEFAULT_STUN_SERVERS];\r\n  \r\n  if (includeTurn && TURN_SERVERS.length > 0) {\r\n    iceServers.push(...TURN_SERVERS);\r\n  }\r\n  \r\n  return iceServers;\r\n}\r\n\r\n/**\r\n * Get STUN servers only (for basic connectivity)\r\n * @returns {Array} Array of STUN server configurations\r\n */\r\nexport function getStunServers() {\r\n  return DEFAULT_STUN_SERVERS;\r\n}\r\n\r\n/**\r\n * Check if TURN servers are configured\r\n * @returns {boolean} True if TURN servers are available\r\n */\r\nexport function hasTurnServers() {\r\n  return TURN_SERVERS.length > 0 && \r\n         process.env.TURN_USERNAME && \r\n         process.env.TURN_PASSWORD;\r\n}\r\n\r\n/**\r\n * Get connection quality based on ICE gathering state\r\n * @param {RTCPeerConnection} peerConnection - The peer connection to check\r\n * @returns {string} Connection quality ('excellent', 'good', 'poor', 'unknown')\r\n */\r\nexport function getConnectionQuality(peerConnection) {\r\n  if (!peerConnection) return 'unknown';\r\n  \r\n  // This is a simplified implementation\r\n  // In a real app, you'd analyze the stats for connection quality\r\n  \r\n  switch (peerConnection.connectionState) {\r\n    case 'connected':\r\n      return 'excellent';\r\n    case 'connecting':\r\n      return 'good';\r\n    case 'disconnected':\r\n    case 'failed':\r\n      return 'poor';\r\n    default:\r\n      return 'unknown';\r\n  }\r\n}\r\n\r\n/**\r\n * Configure WebRTC with optimal settings\r\n * @param {RTCPeerConnection} peerConnection - The peer connection to configure\r\n * @param {boolean} useTurn - Whether to use TURN servers\r\n */\r\nexport function configureWebRTC(peerConnection, useTurn = false) {\r\n  if (!peerConnection) return;\r\n  \r\n  // Set ICE servers\r\n  peerConnection.setConfiguration({\r\n    iceServers: getIceServers(useTurn),\r\n    iceCandidatePoolSize: 10,\r\n    iceTransportPolicy: useTurn ? 'all' : 'all',\r\n    bundlePolicy: 'max-bundle',\r\n    rtcpMuxPolicy: 'require',\r\n  });\r\n  \r\n  // Configure ICE gathering\r\n  peerConnection.addEventListener('icegatheringstatechange', () => {\r\n    console.log('ICE gathering state:', peerConnection.iceGatheringState);\r\n  });\r\n  \r\n  peerConnection.addEventListener('iceconnectionstatechange', () => {\r\n    console.log('ICE connection state:', peerConnection.iceConnectionState);\r\n  });\r\n}\r\n\r\nexport default {\r\n  getIceServers,\r\n  getStunServers,\r\n  hasTurnServers,\r\n  getConnectionQuality,\r\n  configureWebRTC,\r\n};\r\n","import { useState, useEffect, useRef, useCallback } from 'react';\r\nimport { getIceServers } from '../config/turn.js';\r\n\r\nexport function useWebRTC(roomId, role, config, _viewerId = null) {\r\n  // State\r\n  const [connectionState, setConnectionState] = useState('disconnected');\r\n  const [remoteStream, setRemoteStream] = useState(null);\r\n  const [localStream, setLocalStream] = useState(null);\r\n  const [error, setError] = useState(null);\r\n  const [_peerConnections, _setPeerConnections] = useState({});\r\n  const [iceServers, setIceServers] = useState([]);\r\n\r\n  // Refs\r\n  const peerConnectionRef = useRef(null);\r\n  const dataChannelRef = useRef(null);\r\n  const answerIntervalRef = useRef(null);\r\n  const candidateIntervalRef = useRef(null);\r\n\r\n  // Initialize ICE servers\r\n  useEffect(() => {\r\n    // Use TURN server configuration\r\n    const servers = getIceServers(config?.useTurn || false);\r\n    setIceServers(servers);\r\n  }, [config]);\r\n\r\n  // Send ICE candidate\r\n  const sendICECandidate = useCallback(\r\n    async (candidate) => {\r\n      if (!roomId || !role) return;\r\n\r\n      try {\r\n        const response = await fetch('/api/candidate', {\r\n          method: 'POST',\r\n          headers: {\r\n            'Content-Type': 'application/json',\r\n            ...(config?.authSecret && { 'x-auth-secret': config.authSecret }),\r\n          },\r\n          body: JSON.stringify({\r\n            roomId,\r\n            role,\r\n            candidate: {\r\n              candidate: candidate.candidate,\r\n              sdpMid: candidate.sdpMid,\r\n              sdpMLineIndex: candidate.sdpMLineIndex,\r\n            },\r\n          }),\r\n        });\r\n\r\n        if (!response.ok) {\r\n          throw new Error(`Failed to send ICE candidate: ${response.status}`);\r\n        }\r\n      } catch (err) {\r\n        console.error('Error sending ICE candidate:', err);\r\n        setError(`Failed to send ICE candidate: ${err.message}`);\r\n      }\r\n    },\r\n    [roomId, role, config]\r\n  );\r\n\r\n  // Create peer connection\r\n  const createPeerConnection = useCallback(() => {\r\n    const pc = new RTCPeerConnection({\r\n      iceServers,\r\n    });\r\n\r\n    // Handle ICE candidates\r\n    pc.onicecandidate = (event) => {\r\n      if (event.candidate) {\r\n        sendICECandidate(event.candidate);\r\n      }\r\n    };\r\n\r\n    // Handle connection state changes\r\n    pc.onconnectionstatechange = () => {\r\n      console.log('Connection state changed:', pc.connectionState);\r\n      setConnectionState(pc.connectionState);\r\n    };\r\n\r\n    // Handle ICE connection state changes\r\n    pc.oniceconnectionstatechange = () => {\r\n      console.log('ICE connection state changed:', pc.iceConnectionState);\r\n    };\r\n\r\n    // Handle remote stream\r\n    pc.ontrack = (event) => {\r\n      console.log('Received remote stream:', event.streams[0]);\r\n      setRemoteStream(event.streams[0]);\r\n    };\r\n\r\n    // Handle data channel\r\n    pc.ondatachannel = (event) => {\r\n      const channel = event.channel;\r\n      dataChannelRef.current = channel;\r\n\r\n      channel.onopen = () => {\r\n        console.log('Data channel opened');\r\n      };\r\n\r\n      channel.onmessage = (event) => {\r\n        console.log('Received data channel message:', event.data);\r\n      };\r\n    };\r\n\r\n    return pc;\r\n  }, [iceServers, sendICECandidate]);\r\n\r\n  // Send offer\r\n  const sendOffer = useCallback(\r\n    async (offer) => {\r\n      if (!roomId) return;\r\n\r\n      try {\r\n        const response = await fetch('/api/offer', {\r\n          method: 'POST',\r\n          headers: {\r\n            'Content-Type': 'application/json',\r\n            ...(config?.authSecret && { 'x-auth-secret': config.authSecret }),\r\n          },\r\n          body: JSON.stringify({\r\n            roomId,\r\n            desc: offer,\r\n          }),\r\n        });\r\n\r\n        if (!response.ok) {\r\n          throw new Error(`Failed to send offer: ${response.status}`);\r\n        }\r\n      } catch (err) {\r\n        console.error('Error sending offer:', err);\r\n        setError(`Failed to send offer: ${err.message}`);\r\n      }\r\n    },\r\n    [roomId, config]\r\n  );\r\n\r\n  // Send answer\r\n  const sendAnswer = useCallback(\r\n    async (answer) => {\r\n      if (!roomId) return;\r\n\r\n      try {\r\n        const response = await fetch('/api/answer', {\r\n          method: 'POST',\r\n          headers: {\r\n            'Content-Type': 'application/json',\r\n            ...(config?.authSecret && { 'x-auth-secret': config.authSecret }),\r\n          },\r\n          body: JSON.stringify({\r\n            roomId,\r\n            desc: answer,\r\n          }),\r\n        });\r\n\r\n        if (!response.ok) {\r\n          throw new Error(`Failed to send answer: ${response.status}`);\r\n        }\r\n      } catch (err) {\r\n        console.error('Error sending answer:', err);\r\n        setError(`Failed to send answer: ${err.message}`);\r\n      }\r\n    },\r\n    [roomId, config]\r\n  );\r\n\r\n  // Start polling for offers (viewer)\r\n  const startOfferPolling = useCallback(async () => {\r\n    if (answerIntervalRef.current) {\r\n      clearInterval(answerIntervalRef.current);\r\n    }\r\n\r\n    let pollCount = 0;\r\n    let pollInterval = 1000; // Start with 1 second\r\n\r\n    answerIntervalRef.current = setInterval(async () => {\r\n      try {\r\n        const response = await fetch(`/api/offer?roomId=${roomId}`);\r\n\r\n        if (response.ok) {\r\n          const data = await response.json();\r\n          if (data.desc) {\r\n            // Clear interval once we get an offer\r\n            clearInterval(answerIntervalRef.current);\r\n            answerIntervalRef.current = null;\r\n\r\n            // Handle the offer\r\n            const pc = peerConnectionRef.current;\r\n            if (pc) {\r\n              await pc.setRemoteDescription(data.desc);\r\n\r\n              // Create and send answer\r\n              const answer = await pc.createAnswer();\r\n              await pc.setLocalDescription(answer);\r\n              await sendAnswer(answer);\r\n            }\r\n          }\r\n        } else if (response.status === 404) {\r\n          // Expected 404 - no offer yet, but reduce polling frequency after initial attempts\r\n          pollCount++;\r\n          if (pollCount > 10) {\r\n            // After 10 seconds, reduce to polling every 5 seconds\r\n            clearInterval(answerIntervalRef.current);\r\n            pollInterval = 5000;\r\n            answerIntervalRef.current = setInterval(arguments.callee, pollInterval);\r\n          }\r\n        } else {\r\n          // Unexpected error\r\n          console.error('Unexpected error polling for offers:', response.status);\r\n        }\r\n      } catch (err) {\r\n        console.error('Error polling for offers:', err);\r\n      }\r\n    }, pollInterval);\r\n  }, [roomId, sendAnswer]);\r\n\r\n  // Start polling for answers (host)\r\n  const startAnswerPolling = useCallback(async () => {\r\n    if (answerIntervalRef.current) {\r\n      clearInterval(answerIntervalRef.current);\r\n    }\r\n\r\n    let pollCount = 0;\r\n    let pollInterval = 1000; // Start with 1 second\r\n\r\n    answerIntervalRef.current = setInterval(async () => {\r\n      try {\r\n        const response = await fetch(`/api/answer?roomId=${roomId}`);\r\n\r\n        if (response.ok) {\r\n          const data = await response.json();\r\n          if (data.desc) {\r\n            // Clear interval once we get an answer\r\n            clearInterval(answerIntervalRef.current);\r\n            answerIntervalRef.current = null;\r\n\r\n            // Handle the answer\r\n            const pc = peerConnectionRef.current;\r\n            if (pc) {\r\n              await pc.setRemoteDescription(data.desc);\r\n            }\r\n          }\r\n        } else if (response.status === 404) {\r\n          // Expected 404 - no answer yet, but reduce polling frequency after initial attempts\r\n          pollCount++;\r\n          if (pollCount > 10) {\r\n            // After 10 seconds, reduce to polling every 5 seconds\r\n            clearInterval(answerIntervalRef.current);\r\n            pollInterval = 5000;\r\n            answerIntervalRef.current = setInterval(arguments.callee, pollInterval);\r\n          }\r\n        } else {\r\n          // Unexpected error\r\n          console.error('Unexpected error polling for answers:', response.status);\r\n        }\r\n      } catch (err) {\r\n        console.error('Error polling for answers:', err);\r\n      }\r\n    }, pollInterval);\r\n  }, [roomId]);\r\n\r\n  // Start polling for ICE candidates\r\n  const startCandidatePolling = useCallback(async () => {\r\n    if (candidateIntervalRef.current) {\r\n      clearInterval(candidateIntervalRef.current);\r\n    }\r\n\r\n    candidateIntervalRef.current = setInterval(async () => {\r\n      try {\r\n        const response = await fetch(`/api/candidate?roomId=${roomId}&role=${role}`);\r\n\r\n        if (response.ok) {\r\n          const data = await response.json();\r\n          if (data.candidates && data.candidates.length > 0) {\r\n            const pc = peerConnectionRef.current;\r\n            if (pc) {\r\n              for (const candidate of data.candidates) {\r\n                await pc.addIceCandidate(candidate);\r\n              }\r\n            }\r\n          }\r\n        }\r\n      } catch (err) {\r\n        console.error('Error polling for ICE candidates:', err);\r\n      }\r\n    }, 1000);\r\n  }, [roomId, role]);\r\n\r\n  // Start screen sharing (host)\r\n  const startScreenShare = useCallback(async () => {\r\n    if (role !== 'host') {\r\n      throw new Error('Only hosts can start screen sharing');\r\n    }\r\n\r\n    try {\r\n      setError(null);\r\n      setConnectionState('connecting');\r\n\r\n      // Get screen share stream\r\n      const stream = await navigator.mediaDevices.getDisplayMedia({\r\n        video: true,\r\n        audio: true,\r\n      });\r\n\r\n      setLocalStream(stream);\r\n\r\n      // Create peer connection\r\n      const pc = createPeerConnection();\r\n      peerConnectionRef.current = pc;\r\n\r\n      // Add stream to peer connection\r\n      stream.getTracks().forEach((track) => {\r\n        pc.addTrack(track, stream);\r\n      });\r\n\r\n      // Create and send offer\r\n      const offer = await pc.createOffer({\r\n        offerToReceiveAudio: true,\r\n        offerToReceiveVideo: true,\r\n      });\r\n\r\n      await pc.setLocalDescription(offer);\r\n      await sendOffer(offer);\r\n\r\n      // Start polling for answers\r\n      startAnswerPolling();\r\n\r\n      return stream;\r\n    } catch (err) {\r\n      console.error('Error starting screen share:', err);\r\n      setError(`Failed to start screen sharing: ${err.message}`);\r\n      setConnectionState('disconnected');\r\n      throw err;\r\n    }\r\n  }, [role, createPeerConnection, sendOffer, startAnswerPolling]);\r\n\r\n  // Connect to host (viewer)\r\n  const connectToHost = useCallback(async () => {\r\n    if (role !== 'viewer') {\r\n      throw new Error('Only viewers can connect to host');\r\n    }\r\n\r\n    try {\r\n      setError(null);\r\n      setConnectionState('connecting');\r\n\r\n      // Create peer connection\r\n      const pc = createPeerConnection();\r\n      peerConnectionRef.current = pc;\r\n\r\n      // Start polling for offers\r\n      startOfferPolling();\r\n\r\n      // Start polling for ICE candidates\r\n      startCandidatePolling();\r\n    } catch (err) {\r\n      console.error('Error connecting to host:', err);\r\n      setError(`Failed to connect to host: ${err.message}`);\r\n      setConnectionState('disconnected');\r\n      throw err;\r\n    }\r\n  }, [role, createPeerConnection, startCandidatePolling, startOfferPolling]);\r\n\r\n  // Stop screen sharing\r\n  const stopScreenShare = useCallback(async () => {\r\n    try {\r\n      // Stop local stream\r\n      if (localStream) {\r\n        localStream.getTracks().forEach((track) => track.stop());\r\n        setLocalStream(null);\r\n      }\r\n\r\n      // Close peer connection\r\n      if (peerConnectionRef.current) {\r\n        peerConnectionRef.current.close();\r\n        peerConnectionRef.current = null;\r\n      }\r\n\r\n      // Clear intervals\r\n      if (answerIntervalRef.current) {\r\n        clearInterval(answerIntervalRef.current);\r\n        answerIntervalRef.current = null;\r\n      }\r\n\r\n      if (candidateIntervalRef.current) {\r\n        clearInterval(candidateIntervalRef.current);\r\n        candidateIntervalRef.current = null;\r\n      }\r\n\r\n      setConnectionState('disconnected');\r\n      setRemoteStream(null);\r\n    } catch (err) {\r\n      console.error('Error stopping screen share:', err);\r\n      setError(`Failed to stop screen sharing: ${err.message}`);\r\n    }\r\n  }, [localStream]);\r\n\r\n  // Disconnect\r\n  const disconnect = useCallback(async () => {\r\n    await stopScreenShare();\r\n  }, [stopScreenShare]);\r\n\r\n  // Start polling for offers (viewer)\r\n\r\n  // Cleanup on unmount\r\n  useEffect(() => {\r\n    return () => {\r\n      if (answerIntervalRef.current) {\r\n        clearInterval(answerIntervalRef.current);\r\n      }\r\n      if (candidateIntervalRef.current) {\r\n        clearInterval(candidateIntervalRef.current);\r\n      }\r\n      if (peerConnectionRef.current) {\r\n        peerConnectionRef.current.close();\r\n      }\r\n      if (localStream) {\r\n        localStream.getTracks().forEach((track) => track.stop());\r\n      }\r\n    };\r\n  }, [localStream]);\r\n\r\n  return {\r\n    // State\r\n    connectionState,\r\n    remoteStream,\r\n    localStream,\r\n    error,\r\n    peerConnections: _peerConnections,\r\n\r\n    // Actions\r\n    startScreenShare,\r\n    stopScreenShare,\r\n    connectToHost,\r\n    disconnect,\r\n  };\r\n}\r\n"],"names":["VideoPlayer","forwardRef","className","props","ref","videoRef","useRef","internalRef","useEffect","video","handleLoadedMetadata","handleLoadedData","handleCanPlay","handlePlay","handlePause","handleEnded","handleError","e","handleWaiting","handleStalled","DEFAULT_STUN_SERVERS","TURN_SERVERS","define_process_env_default","getIceServers","includeTurn","iceServers","useWebRTC","roomId","role","config","_viewerId","connectionState","setConnectionState","useState","remoteStream","setRemoteStream","localStream","setLocalStream","error","setError","_peerConnections","_setPeerConnections","setIceServers","peerConnectionRef","dataChannelRef","answerIntervalRef","candidateIntervalRef","servers","sendICECandidate","useCallback","candidate","response","err","createPeerConnection","pc","event","channel","sendOffer","offer","sendAnswer","answer","startOfferPolling","pollCount","pollInterval","data","startAnswerPolling","startCandidatePolling","startScreenShare","stream","track","connectToHost","stopScreenShare","disconnect"],"mappings":"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"}