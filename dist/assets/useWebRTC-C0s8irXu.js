import{r as n,j as W}from"./main-D4-U2-r8.js";const J=n.forwardRef(({className:s,...i},d)=>{const w=n.useRef(null),E=d||w;return n.useImperativeHandle(d,()=>w.current,[]),n.useEffect(()=>{const r=E.current;if(!r)return;const I=()=>{console.log("Video metadata loaded:",{duration:r.duration,videoWidth:r.videoWidth,videoHeight:r.videoHeight})},y=()=>{console.log("Video data loaded")},h=()=>{console.log("Video can start playing")},m=()=>{console.log("Video started playing")},R=()=>{console.log("Video paused")},l=()=>{console.log("Video ended")},k=$=>{console.error("Video error:",$)},T=()=>{console.log("Video waiting for data")},S=()=>{console.log("Video stalled")};return r.addEventListener("loadedmetadata",I),r.addEventListener("loadeddata",y),r.addEventListener("canplay",h),r.addEventListener("play",m),r.addEventListener("pause",R),r.addEventListener("ended",l),r.addEventListener("error",k),r.addEventListener("waiting",T),r.addEventListener("stalled",S),()=>{r.removeEventListener("loadedmetadata",I),r.removeEventListener("loadeddata",y),r.removeEventListener("canplay",h),r.removeEventListener("play",m),r.removeEventListener("pause",R),r.removeEventListener("ended",l),r.removeEventListener("error",k),r.removeEventListener("waiting",T),r.removeEventListener("stalled",S)}},[E]),W.jsx("video",{ref:E,className:s,...i})});J.displayName="VideoPlayer";const _=[{urls:"stun:stun.l.google.com:19302"},{urls:"stun:stun1.l.google.com:19302"},{urls:"stun:stun2.l.google.com:19302"},{urls:"stun:stun3.l.google.com:19302"},{urls:"stun:stun4.l.google.com:19302"}],D=[{urls:"turn:openrelay.metered.ca:80",username:"openrelayproject",credential:"openrelayproject"},{urls:"turn:openrelay.metered.ca:443",username:"openrelayproject",credential:"openrelayproject"},{urls:"turn:openrelay.metered.ca:443?transport=tcp",username:"openrelayproject",credential:"openrelayproject"}];function q(s=!1){const i=[..._];return s&&D.length>0&&i.push(...D),i}function B(s,i,d,w=null){const[E,r]=n.useState("disconnected"),[I,y]=n.useState(null),[h,m]=n.useState(null),[R,l]=n.useState(null),[k,T]=n.useState({}),[S,$]=n.useState([]),v=n.useRef(null),M=n.useRef(null),a=n.useRef(null),o=n.useRef(null),f=n.useRef(null);n.useEffect(()=>{const e=q(d?.useTurn!==!1);$(e)},[d]);const b=n.useCallback(async e=>{if(!(!s||!i))try{const t=await fetch("/api/candidate",{method:"POST",headers:{"Content-Type":"application/json",...d?.authSecret&&{"x-auth-secret":d.authSecret}},body:JSON.stringify({roomId:s,role:i,viewerId:w,candidate:{candidate:e.candidate,sdpMid:e.sdpMid,sdpMLineIndex:e.sdpMLineIndex}})});if(!t.ok)throw new Error(`Failed to send ICE candidate: ${t.status}`)}catch(t){console.error("Error sending ICE candidate:",t),l(`Failed to send ICE candidate: ${t.message}`)}},[s,i,d]),L=n.useCallback(()=>{const e=new RTCPeerConnection({iceServers:S});return e.onicecandidate=t=>{t.candidate&&b(t.candidate)},e.onconnectionstatechange=()=>{console.log("Connection state changed:",e.connectionState),r(e.connectionState),(e.connectionState==="connected"||e.connectionState==="failed")&&(a.current&&(clearInterval(a.current),a.current=null),o.current&&(clearInterval(o.current),o.current=null),f.current&&(clearInterval(f.current),f.current=null))},e.oniceconnectionstatechange=()=>{console.log("ICE connection state changed:",e.iceConnectionState)},e.ontrack=t=>{console.log("Received remote stream:",t.streams[0]),y(t.streams[0])},e.ondatachannel=t=>{const u=t.channel;M.current=u,u.onopen=()=>{console.log("Data channel opened")},u.onmessage=p=>{console.log("Received data channel message:",p.data)}},e},[S,b]),j=n.useCallback(async e=>{if(s)try{const t=await fetch("/api/offer",{method:"POST",headers:{"Content-Type":"application/json",...d?.authSecret&&{"x-auth-secret":d.authSecret}},body:JSON.stringify({roomId:s,desc:e})});if(!t.ok)throw new Error(`Failed to send offer: ${t.status}`)}catch(t){console.error("Error sending offer:",t),l(`Failed to send offer: ${t.message}`)}},[s,d]),V=n.useCallback(async e=>{if(s)try{const t=await fetch("/api/answer",{method:"POST",headers:{"Content-Type":"application/json",...d?.authSecret&&{"x-auth-secret":d.authSecret}},body:JSON.stringify({roomId:s,desc:e})});if(!t.ok)throw new Error(`Failed to send answer: ${t.status}`)}catch(t){console.error("Error sending answer:",t),l(`Failed to send answer: ${t.message}`)}},[s,d]),x=n.useCallback(async()=>{a.current&&clearInterval(a.current);let e=0,t=1e3;const u=60,p=async()=>{try{if(e++,e>u){clearInterval(a.current),a.current=null,l("Connection timeout: No offer received from host. Make sure the host has started sharing."),r("failed");return}const c=await fetch(`/api/offer?roomId=${s}`);if(c.ok){const C=await c.json();if(C.desc){clearInterval(a.current),a.current=null;const g=L();v.current=g,await g.setRemoteDescription(C.desc);const N=await g.createAnswer();await g.setLocalDescription(N),await V(N),O()}}else c.status===404?e>10&&(clearInterval(a.current),t=5e3,a.current=setInterval(p,t)):(console.error("Unexpected error polling for offers:",c.status),clearInterval(a.current),a.current=null,l(`Server error: ${c.status}`),r("failed"))}catch(c){console.error("Error polling for offers:",c),clearInterval(a.current),a.current=null,l(`Network error: ${c.message}`),r("failed")}};a.current=setInterval(p,t)},[s,V,L,O]),F=n.useCallback(async()=>{o.current&&clearInterval(o.current);let e=0,t=1e3;const u=60,p=async()=>{try{if(e++,e>u){clearInterval(o.current),o.current=null,l("Connection timeout: No answer received from viewer. Make sure the viewer has connected."),r("failed");return}const c=await fetch(`/api/answer?roomId=${s}`);if(c.ok){const C=await c.json();if(C.desc){clearInterval(o.current),o.current=null;const g=v.current;g&&await g.setRemoteDescription(C.desc)}}else c.status===404?e>10&&(clearInterval(o.current),t=5e3,o.current=setInterval(p,t)):(console.error("Unexpected error polling for answers:",c.status),clearInterval(o.current),o.current=null,l(`Server error: ${c.status}`),r("failed"))}catch(c){console.error("Error polling for answers:",c),clearInterval(o.current),o.current=null,l(`Network error: ${c.message}`),r("failed")}};o.current=setInterval(p,t)},[s]),O=n.useCallback(async()=>{f.current&&clearInterval(f.current),f.current=setInterval(async()=>{try{const e=await fetch(`/api/candidate?roomId=${s}&role=${i}${w?`&viewerId=${w}`:""}`);if(e.ok){const t=await e.json();if(t.candidates&&t.candidates.length>0){const u=v.current;if(u)for(const p of t.candidates)try{await u.addIceCandidate(p)}catch(c){console.warn("Failed to add ICE candidate:",c)}}}else e.status!==404&&console.error("Error polling for ICE candidates:",e.status)}catch(e){console.error("Error polling for ICE candidates:",e)}},1e3)},[s,i]),A=n.useCallback(async()=>{if(i!=="host")throw new Error("Only hosts can start screen sharing");try{l(null),r("connecting");const e=await navigator.mediaDevices.getDisplayMedia({video:!0,audio:!0});m(e);const t=L();v.current=t,e.getTracks().forEach(p=>{t.addTrack(p,e)});const u=await t.createOffer({offerToReceiveAudio:!0,offerToReceiveVideo:!0});return await t.setLocalDescription(u),await j(u),F(),e}catch(e){throw console.error("Error starting screen share:",e),l(`Failed to start screen sharing: ${e.message}`),r("disconnected"),e}},[i,L,j,F]),U=n.useCallback(async()=>{if(i!=="viewer")throw new Error("Only viewers can connect to host");try{l(null),r("connecting"),x()}catch(e){throw console.error("Error connecting to host:",e),l(`Failed to connect to host: ${e.message}`),r("disconnected"),e}},[i,x]),P=n.useCallback(async()=>{try{h&&(h.getTracks().forEach(e=>e.stop()),m(null)),v.current&&(v.current.close(),v.current=null),a.current&&(clearInterval(a.current),a.current=null),o.current&&(clearInterval(o.current),o.current=null),f.current&&(clearInterval(f.current),f.current=null),r("disconnected"),y(null)}catch(e){console.error("Error stopping screen share:",e),l(`Failed to stop screen sharing: ${e.message}`)}},[h]),H=n.useCallback(async()=>{await P()},[P]);return n.useEffect(()=>()=>{a.current&&clearInterval(a.current),o.current&&clearInterval(o.current),f.current&&clearInterval(f.current),v.current&&v.current.close(),h&&h.getTracks().forEach(e=>e.stop())},[h]),{connectionState:E,remoteStream:I,localStream:h,error:R,peerConnections:k,startScreenShare:A,stopScreenShare:P,connectToHost:U,disconnect:H}}export{J as V,B as u};
//# sourceMappingURL=useWebRTC-C0s8irXu.js.map
